# Week 5 - Harvesting and bifurcation{-} 

In this lab section, we're going to analyze the budworm population dynamic model from [**Ludwig et al., 1978**](https://doi.org/10.2307/3939).

<br>
**Part 1 - Stability of the budworm model**

In part 1 we're going to visulize the stability of the budworm model, by plotting the differential equation. By plotting the the differential equation with different initial, we could see that the number of equilibrium changes. 

\[
\dfrac{dN}{dt} = rN(1 - \dfrac{N}{K}) - \dfrac{BN^2}{A^2 + N^2}
\]

```{r}
#### Plotting the functional form for different parameters
#### Parameter setting
r <- 0.055; K <- 10; B <- 0.1; A <- 1

#### Visualize the whole dN/dt
N.vec <- seq(from = 0, to = 10, length = 500)
r.breaks <- c(0.03, 0.05, 0.07)
dat <- outer(X = N.vec, Y = r.breaks,
             function(N, r){r * N * (1 - N / K) - (B * N^2 / (A^2 + N^2))})
matplot(x = N.vec, y = dat, type = "l", 
        xlab = "N", ylab = "dN/dt", col = "blue", lwd = 2, las = 1)
abline(h = 0)
legend("bottomleft", legend = r.breaks, title = "r", col = "blue", lty=1:3, lwd = 2)
```
\[
\dfrac{dN}{dt}[r(1 - \dfrac{N}{K})] = \dfrac{dN}{dt}[\dfrac{BN^2}{A^2 + N^2}]
\]
```{r}
#### Visualize separate components of dN/dt
N.vec <- seq(from = 0, to = 10, length = 500)
r.breaks <- c(0.03, 0.05, 0.07)
dat.growth <- outer(X = N.vec, Y = r.breaks,
                    function(N, r){r * (1 - N / K)}) 
matplot(x = N.vec, y = dat.growth, type = "l", ylim = c(0, 0.08), las = 1, 
        xlab = "N", ylab = "growth / harvest rate", col = "blue", lwd = 2)
curve(B * x / (A^2 + x^2), add = T, col = "red", lwd = 2) # Just curve since its the same line, and note variable notation change
abline(h = 0)
legend("topright", legend = r.breaks, title = "r", col = "blue", lty=1:3, lwd = 2)

#### 2-D bifurcation diagram following analytical solution from Strogatz
#### For nondimensionalized model dx/du = rx(1-x/k) - x^2/(1+x^2)
#### There exist parametric curves for bifurcation points r(x) and k(x)
x.bifur = seq(1.001, 50, by = 0.001)
bifur2D = data.frame(x.bifur = x.bifur, 
                     r.bifur = 2 * x.bifur^3 / ((1 + x.bifur^2)^2),
                     k.bifur = 2 * x.bifur^3 / (x.bifur^2 - 1))
plot(r.bifur ~ k.bifur, bifur2D, type = "l", lwd = 2, las = 1, 
     xlim = c(0, 60), ylim = c(0, max(bifur2D$r.bifur) * 1.1), 
     xlab = "K", ylab = "r", main = "Budworm model bifurcation along r-k space")
```

<!-- **Part 2 - Using "deSolve" function "ode" to brute-force stable solution** -->
<!-- ```{r} -->
<!-- #### Budworm model for deSolve -->
<!-- BudwormODE <- function(times, state, parms) { -->
<!--   with(as.list(c(state, parms)), { -->
<!--     dN_dt = r * N * (1 - N / K) - (B * N^2 / (A^2 + N^2)) -->
<!--     return(list(c(dN_dt)))   -->
<!--   }) -->
<!-- } -->

<!-- ### Parameters setting -->
<!-- times <- seq(0, 10000, by = 10)  -->
<!-- state <- c(N = 10)  -->

<!-- #### Bifurcation diagram for r -- the forward branch -->
<!-- ### Set first forward simulation and saving space -->
<!-- r.vec.forward <- seq(0.01, 0.07, by = 0.00001) -->
<!-- parms <- c(r = r.vec.forward[1], K = 10, B = 0.1, A = 1)   -->
<!-- temp <- deSolve::ode(func = BudwormODE, times = times, y = state, parms = parms) -->
<!-- forward <- matrix(rep(unname(c(r.vec.forward[1], temp[length(times), 2])), length(r.vec.forward)), -->
<!--                   nrow = length(r.vec.forward), ncol = 2, byrow = T) -->

<!-- ## Run across forward vector, using previous step equilibrium as new initial state -->
<!-- for(i in 2:length(r.vec.forward)){ -->
<!--   state <- c(N = forward[i-1, 2])   -->
<!--   parms <- c(r = r.vec.forward[i], K = 10, B = 0.1, A = 1)  -->
<!--   temp <- deSolve::ode(func = BudwormODE, times = times, y = state, parms = parms) -->
<!--   forward[i, ] = unname(c(r.vec.forward[i], temp[length(times), 2])) -->
<!-- } -->

<!-- #### Bifurcation diagram for r -- the backward branch -->
<!-- ## Set first backward simulation and saving space -->
<!-- r.vec.backward <- rev(r.vec.forward) -->
<!-- parms <- c(r = r.vec.backward[1], K = 10, B = 0.1, A = 1)   -->
<!-- temp <- deSolve::ode(func = BudwormODE, times = times, y = state, parms = parms) -->
<!-- backward <- matrix(rep(unname(c(r.vec.backward[1], temp[length(times), 2])), length(r.vec.backward)), -->
<!--                    nrow = length(r.vec.backward), ncol = 2, byrow = T) -->

<!-- ## Run across backward vector, using previous step equilibrium as new initial state -->
<!-- for(i in 2:length(r.vec.backward)){ -->
<!--   state <- c(N = backward[i-1, 2])   -->
<!--   parms <- c(r = r.vec.backward[i], K = 10, B = 0.1, A = 1)  -->
<!--   temp <- deSolve::ode(func = BudwormODE, times = times, y = state, parms = parms) -->
<!--   backward[i, ] = unname(c(r.vec.backward[i], temp[length(times), 2])) -->
<!-- } -->

<!-- #### Plot both forward and backward branch -->
<!-- plot(forward[, 1], forward[, 2], -->
<!--      xlim = range(r.vec.forward), ylim = c(0, 10), las = 1, pch = 15, col = "darkblue",   -->
<!--      xlab = "r", ylab = "Equilibrium density, N*", main = "Budworm model bifurcation along r") -->
<!-- points(backward[, 1], backward[, 2], pch = 15, col = "darkblue") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #### Stability of the budworm model, as a function of its parameters -->
<!-- #### Using "rootSolve" function "gradient" and "uniroot.all"  -->
<!-- #### Works best for simple models and those with known solutions -->
<!-- ######################################################################################################################## -->
<!-- #### Load package and parameter setting -->
<!-- require(rootSolve)  -->
<!-- r <- 0.055 -->
<!-- K <- 10 -->
<!-- B <- 0.1 -->
<!-- A <- 1 -->

<!-- #### Spruce budworm model for rootSolve -->
<!-- Budworm <- function(N, r = 0.055, K = 10){ -->
<!--   r * N * (1 - N / K) - (B * N^2 / (A^2 + N^2)) -->
<!-- }  -->

<!-- #### Function of root stability   -->
<!-- Stability <- function(r = 0.055, K = 10){ -->
<!--   equilibrium <- uniroot.all(f = Budworm, interval = c(0, K), r = r, K = K) # finds all roots -->
<!--   lambda <- vector(mode = "numeric", length = length(equilibrium)) -->
<!--   for(i in 1:length(equilibrium)){ -->
<!--     lambda[i] <- sign(gradient(f = Budworm, x = equilibrium[i], r = r, K = K )) -->
<!--   } -->
<!--   return(list(Equilibrium = equilibrium,  -->
<!--               Lambda = lambda)) -->
<!-- } -->

<!-- #### Bifurcation diagram for r -->
<!-- r.vec <- seq(0.01, 0.07, by = 0.0001) -->

<!-- ## Create plotting frame -->
<!-- plot(0, xlim = range(r.vec), ylim = c(0, 10), type = "n", las = 1,  -->
<!--      xlab = "r", ylab = "Equilibrium density, N*", main = "Budworm model bifurcation along r") -->
<!-- legend("topleft", pch = 15, pt.cex = 2, c("stable", "unstable"), -->
<!--        col = c("darkblue", "lightblue")) -->

<!-- ## Calculate number of roots and stability across range or r -->
<!-- for(r in r.vec){ -->
<!--   temp <- Stability(r = r)  -->
<!--   points(x = rep(r, length(temp$Equilibrium)),  -->
<!--          y = temp$Equilibrium,  -->
<!--          pch = 15, col = ifelse(temp$Lambda == -1, "darkblue", "lightblue")) -->
<!-- } -->

<!-- #### Bifurcation diagram for K -->
<!-- K.vec <- seq(0.1, 14, by = 0.01) -->

<!-- ## Create plotting frame -->
<!-- plot(0, xlim = range(K.vec), ylim = c(0, 14), type = "n", las = 1,  -->
<!--      xlab = "K", ylab = "Equilibrium density, N*", main = "Budworm model bifurcation along K") -->
<!-- legend("topleft", pch = 15, pt.cex = 2, c("stable", "unstable"), -->
<!--        col = c("darkblue", "lightblue")) -->

<!-- ## Calculate number of roots and stability across range or r -->
<!-- for(K in K.vec){ -->
<!--   temp <- Stability(K = K)  -->
<!--   points(x = rep(K, length(temp$Equilibrium)),  -->
<!--          y = temp$Equilibrium,  -->
<!--          pch = 15, col = ifelse(temp$Lambda == -1, "darkblue", "lightblue")) -->
<!-- } -->
<!-- ``` -->
<!-- Take a look a this [**website**](https://www.math.ksu.edu/~albin/teaching/math340_fall2018/slides/03_bifurcations.html) if your interested in more details of bifurcation. -->
