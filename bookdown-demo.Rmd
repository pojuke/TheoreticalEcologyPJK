--- 
title: "Introduction to Theoretical Ecology"
author: "Instructor: Po-Ju Ke $~~~~~$ Teaching Assistant: Guan-Yu Chen"
date: "2025 Fall at National Taiwan Univeristy ![](./bifurcation.gif)"
output:
  html_document:
    df_print: paged
github-repo: pojuke/TheoreticalEcologyPJK
cover-image: bifurcation.gif
site: bookdown::bookdown_site
documentclass: book
bibliography:
- book.bib
- packages.bib
biblio-style: apalike
link-citations: yes
description: This is the course website for **_Introduction to Theoretical Ecology_**
  2025 Fall at National Taiwan University.
url: https://pojuke.github.io/TheoreticalEcologyPJK/
---
# Course information{-}
<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Description** </p> The development of theory plays an important role in advancing ecology as a scientific field. This three-unit course is for students at the graduate or advanced undergraduate level. The course will cover classic theoretical topics in population and community ecology, staring from single-species dynamics and gradually build up to multispecies models. Emphasis will be on theoretical concepts and corresponding mathematical approaches.

This course is designed as a two-hour lecture (written on black board) followed by a one-hour complementary hands-on practice module. In the lecture, we will analyze dynamical models and discuss their theoretical implications. In the practice section, we will use a combination interactive applications and numerical simulations to gain more intuition of the dynamics and behavior of different models. 

<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Objective** </p>
By the end of the course, students are expected to be familiar with the basic building blocks of ecological models, and would be able to formulate and analyze simple models of their own. The hands-on practice component should allow students to link their ecological intuition with the underlying mathematical model, helping them to better understand the primary literature of theoretical ecology. 

<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Requirement** </p>
Students are only expected to have a basic understanding of **Calculus** (e.g., freshman introductory course) and **Ecology**. It's OK if you're not familiar with calculus as we will provide relevant material for you to review during the first week.

<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Format** </p>
Thursday 6,7,8 (1:20 pm ~ 4:20 pm) at Gongtong 207


<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Grading** </p>
The final grade consists of:

(1) Assignment problem sets (60%)
(2) Midterm exam (15%)
(3) Final exam (15%)
(4) Course participation (10%)

<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Course materials** </p>
We will use a combination of textbooks of theoretical ecology. Textbook chapters and additional reading materials (listed in the course outline) will be provided. (see [**Syllabus**](https://pojuke.github.io/TheoreticalEcologyPJK/syllabus.html) for more details).

Below are the textbook references:

(1) *A Primer of Ecology* (4^th^ edition). Nicholas Gotelli, 2008. 
(2) *An Illustrated Guide to Theoretical Ecology*. Ted Case, 2000. 
(3) *A Biologist's Guide to Mathematical Modeling in Ecology and Evolution*. Sarah Otto & Troy Day, 2011. 
(4) *Mathematical Ecology of Populations and Ecosystems*. John Pastor, 2008. 
(5) *Nonlinear Dynamics and Choas*. Steven Strogatz, 2000.


<p style = "font-size: 24pt; margin-bottom: 5px; margin-top: 25px"> **Contacts** </p>
**Instructor**: Po-Ju Ke

- Office: Life Science Building R635
- Email: pojuke@ntu.edu.tw
- Office hours: by appointment

**Teaching assistant**: Guan-Yu Chen

- Office: Life Science Building R635
- Email: r13b44005@ntu.edu.tw
- Office hours: by appointment


# Syllabus {-}
```{r, echo = FALSE, message = F, warning = F, error = F}
library(tidyverse)
library(knitr)
library(kableExtra)

syllabus <- tibble(
  Date = c("**Week 1** <span style='vertical-align:-30%'> </span>
           <br> 9/4",
           "**Week 2** <span style='vertical-align:-30%'> </span>
           <br> 9/11",
           "**Week 3** <span style='vertical-align:-30%'> </span>
           <br> 9/18",
           "**Week 4** <span style='vertical-align:-30%'> </span>
           <br> 9/25",
           "**Week 5** <span style='vertical-align:-30%'> </span>
           <br> 10/2",
           "**Week 6** <span style='vertical-align:-30%'> </span>
           <br> 10/9",
           "**Week 7** <span style='vertical-align:-30%'> </span>
           <br> 10/16",
           "**Week 8** <span style='vertical-align:-30%'> </span>
           <br> 10/23",
           "**Week 9** <span style='vertical-align:-30%'> </span>
           <br> 10/30",
           "**Week 10** <span style='vertical-align:-30%'> </span>
           <br> 11/6",
           "**Week 11** <span style='vertical-align:-30%'> </span>
           <br> 11/13",
           "**Week 12** <span style='vertical-align:-30%'> </span>
           <br> 11/20",
           "**Week 13** <span style='vertical-align:-30%'> </span>
           <br> 11/27",
           "**Week 14** <span style='vertical-align:-30%'> </span>
           <br> 12/4",
           "**Week 15** <span style='vertical-align:-30%'> </span>
           <br> 12/11",
           "**Week 16** <span style='vertical-align:-30%'> </span>
           <br> 12/18"),
  
  `Lecture topic` = c("Introduction: what is theoretical ecology?", #week1
                      "Exponential population growth", #week2
                      "Logistic population growth and stability analysis", #week3
                      "Discrete population growth and stability analysis", #week4
                      "Metapopulations and patch occupancy models", #week5
                      "Harvesting and bifurcation", #week6
                      "Age-structured population models", #week7
                      "Lotka-Volterra model of competition: graphical analysis", #week8
                      "**Midterm exam**", #week9
                      "Lotka-Volterra model of competition: invasion analysis and linear stability analysis", #week10
                      "Predator-prey interactions (I)", #week11
                      "Predator-prey interactions (II)", #week12
                      "Multispecies models of predation: apparent competition", #week13
                      "Mechanistic models for consumer-resource dynamics", #week14
                      "Research applcations: plant-soil feedback as an example", #week15
                      "**Final exam**"), #week16
    
  Lab = c(" \\- ", #week1
          'Solving exponential growth equation using "deSolve" & Visualization', #week2
          "Simulating logistic growth", #week3
          "Logistic map and Ricker diagram", #week4
          "Metapopulations and patch occupancy models", #week5
          "Bifurcation diagram", #week6
          "Age-structured population model", #week7
          "Simulating competitive dynamics and invasion growth", #week8
          " \\-", #week9
          "Visualization of dynamics with complex eigenvalues", #week10
          "Lotka-Volterra model of predator-prey interactions and time-scale separation", #week11
          "Rosenzweig-MacArthur predator-prey model", #week12
          "Consumer-resource dynamics", #week13
          "Parameter space for apparent competition model", #week14
          " \\- ", #week15
          " \\- "), #week16
    
    
  Readings = c("[**Grainger et al., 2021**](https://doi.org/10.1086/717206)",
               "Gotelli [Ch.1], Case[Ch.1]", #week2
               " \\- ", #week3
               "Gotelli [Ch.2], Case[Ch.5], Otto & Day[Ch.5],
               [**May., 1976**](https://doi.org/10.1038/261459a0)", #week4
               "Gotelli [Ch.4], Case[Ch.16]", #week5
               "Pastor [Ch. 7], Strogatz [Ch. 3]", #week6
               "Gotelli [Ch.3], Case[Ch.3]", #week7
               "Gotelli [Ch.5], Case[Ch.14], 
               [**Broekman et al., 2019**]( https://doi.org/10.1111/ele.13349)", #week8
               " \\- ", #week9
               "Otto & Day [Ch.8],
               [**May., 1972**](https://www.nature.com/articles/238413a0)", #week10
               "Gotelli [Ch.6], Case[Ch.12, 13]", #week11
               "Gotelli [Ch.6], Case[Ch.12, 13]", #week12
               "[**Tilman., 1980**](https://doi.org/10.1086/283633),
               [**Armstrong & McGehee., 1980**](https://doi.org/10.1086/283553)", #week13
               "[**Holt., 1977**](https://doi.org/10.1016/0040-5809(77)90042-9)", #week14
               " \\- ",
               " \\- ")  
  
)

kbl(syllabus, align = "cccl", escape = F) %>%  
  kable_paper(full_width = T, 
              html_font = "Arial",
              font_size = 17) %>%
  kable_styling(bootstrap_options = c("bordered")) %>%
  row_spec(0, bold = T, color = "black", font_size = 20) %>%
  column_spec(1, width = "10em", border_right = T) %>%
  column_spec(2, width = "17em") %>%
  column_spec(3, width = "17em") %>%
  column_spec(4, width = "13em")

```



<!--chapter:end:index.Rmd-->

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = F, 
                      error = F, 
                      warning = F)

```

# Week 2 - Exponential population growth {-} 

In part 1, we will solve the differential equation for exponential population growth and visualize how the population sizes change over time. 

<br>

**Part 1 - Numerical solution using the package `deSolve`**

Two main phases:

(1) Model specification: specify the structure of differential equation model

(2) Model application: set the time steps, initial population size and model parameters (e.g., intrinsic population growth rate $r$), and then solve the equation model

<style>

p span#aaa:before { 
  content: "(1) "; 
  display: inline-block;
  margin-left: -1.5em;
  margin-right: 0.3em;
}

p span#bbb:before { 
  content: "(2) "; 
  display: inline-block;
  margin-left: -1.5em;
  margin-right: 0.3em;
}

d-article table.lightable-paper {
  margin-bottom: 0px; 
}

</style>

Consider the model
\[
\frac{dN}{dt} = rN
\]
where $N$ is population size and $r$ is the intrinsic growth rate.
```{r}
###### part 1 ######
# install.packages("deSolve")
library(deSolve)

### (1) Model specification
exponential_model <- function(times, state, parms) {
  with(as.list(c(state, parms)), {
    dN_dt = r*N  # Exponential growth equation
    return(list(c(dN_dt)))  # Return the results
  })
}
```

Set the time steps, initial population size and model parameters.
```{r}
### (2) Model application
times <- seq(0, 10, by = 0.1)  # Time steps to integrate over
state <- c(N = 10)  # Initial population size
parms <- c(r = 1.5)  # Intrinsic growth rate
```

Solve the equation by `ode()` numerically.
```{r}
# Run the ode solver
pop_size <- ode(func = exponential_model, times = times, y = state, parms = parms)

# Take a look at the results
head(pop_size)
```

Visualization
```{r}
plot(N ~ time, data = pop_size)
```

Compare simulation result with analytic solution, which is
\[
N(t) = N_0\exp\{rt\}
\]
```{r}
par(mfrow = c(1,2))
plot(N ~ time, data = pop_size) # Plot simulation data
curve(state[1]*exp(parms[1]*x), col = "red", add = T) # Adding analytic solution
plot(N ~ time, data = pop_size, log = "y") # Plot logged simulation data
curve(state[1]*exp(parms[1]*x), col = "red", add = T) # Adding analytic solution
```


<br>

**Part 2 - Comparing different ode solvers and different time intervals**
<br>
In default of `ode()`, the equations are solved by LSODA method. We can change the method by modifying the argument `method` in `ode()`. 

```{r}

###### part 2 ######
# Original setting
times <- seq(0, 10, by = 0.1)  # Time steps to integrate over
state <- c(N = 10)  # Initial population size
parms <- c(r = 1.5)  # Intrinsic growth rate
# Default: LSODA
pop_size <- ode(func = exponential_model, times = times, y = state, parms = parms)

# Euler's method
pop_size_1 <- ode(func = exponential_model, times = times, y = state, parms = parms, method = "euler")

# Compare different method
par(mfrow = c(1,2))
plot(N ~ time, data = pop_size, main = "LSODA")
curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = "red", add = T) # correct curve
plot(N ~ time, data = pop_size_1, main = "Euler")
curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = "red", add = T) # correct curve

# Different time intervals
times_1 <- seq(0, 10, by = 1)  # time steps to integrate over
times_2 <- seq(0, 10, by = 0.1)  # time steps to integrate over
times_3 <- seq(0, 10, by = 0.01)  # time steps to integrate over

# Euler's method
pop_size_1 <- ode(func = exponential_model, times = times_1, y = state, parms = parms, method = "euler")
pop_size_2 <- ode(func = exponential_model, times = times_2, y = state, parms = parms, method = "euler")
pop_size_3 <- ode(func = exponential_model, times = times_3, y = state, parms = parms, method = "euler")

# Compare different time intervals
par(mfrow = c(1,3))
plot(N ~ time, data = pop_size_1, main = "Time intervals = 1")
curve(state[1]*exp(parms[1]*x), col = "red", add = T) # correct curve
plot(N ~ time, data = pop_size_2, main = "Time intervals = 0.1")
curve(state[1]*exp(parms[1]*x), col = "red", add = T) # correct curve
plot(N ~ time, data = pop_size_3, main = "Time intervals = 0.01")
curve(state[1]*exp(parms[1]*x), col = "red", add = T) # correct curve
```

<br>

**Part 3 - Solving exponential growth model with fluctuating growth rate**
<br>
Consider the model
\[
\frac{dN}{dt} = r(t)N \ \text{, } r(t) = \overline{r} + \sigma\sin(\omega t)
\]
where $\overline{r}$ and $\omega$ are constants.
The analytic solution of the ode model is 
\[
N(t) = N_0\exp\{\overline{r}t - \frac{\sigma}{\omega}[\cos(\omega t) - 1]\}
\]

```{r}
###### part 3 ######
### Model specification
exponential_model_fluc <- function(times, state, parms) {
  with(as.list(c(state, parms)), {
    dN_dt = (r_bar + sigma*sin(omega*times))*N  # exponential growth equation
    return(list(c(dN_dt)))  # return the results
  })
}
```


```{r}
### Parameters
times <- seq(0, 10, by = 0.1)  # time steps to integrate over
state <- c(N = 10)  # initial population size
parms <- c(r_bar = 1.5, sigma = 5, omega = 2*pi)  # intrinsic growth rate
```

Plot $r(t)$
```{r}
### Fluctuating growth rate
r = parms[1] + parms[2]*sin(parms[3]*times)
plot(r ~ times, type = "l")
```

```{r}
### Solving model
pop_size <- ode(func = exponential_model_fluc, times = times, y = state, parms = parms)

### Plotting
plot(N ~ times, data = pop_size)
curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = "red") # correct curve
plot(N ~ times, data = pop_size, log = "y")
curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = "red") # correct curve
```

Adjust $\overline{r}$
```{r}
### Parameters
times <- seq(0, 10, by = 0.1)  # time steps to integrate over
state <- c(N = 10)  # initial population size
parms <- c(r_bar = 0.1, sigma = 5, omega = 2*pi)  # intrinsic growth rate

### Fluctuating growth rate
r = parms[1] + parms[2]*sin(parms[3]*times)
plot(r ~ times, type = "l")

### Solving model
pop_size <- ode(func = exponential_model_fluc, times = times, y = state, parms = parms)

### Plotting
plot(N ~ times, data = pop_size)
curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = "red") # correct curve
```

<!--chapter:end:02_Week_2_Exponential.Rmd-->

# Week 3 - Logistic population growth and stability analysis {.unnumbered}

**Part 1 - Shining app for logistic growth**

```{r, out.width="800px", echo = F}
knitr::include_app("https://genchanghsu0115.shinyapps.io/Logistic_mod_shinyapp/", height = "500px")
```

Credit to [Gen-Chang Hsu](https://genchanghsu.github.io/index.html)

<br> <br> <br> <br> <br>

**Part 2 - Population growth with Allee effects**

Some populations experience negative growth rates when the population size is too low, a phenomenon known as "Allee effect". For example, some flowering plants require a minimal local density to attract pollinators (clustering effects). Below this density, pollinators will not be able to detect the presence of flowers and therefore the plants cannot complete their life cycle. Some flower species, e.g., *Itea*, requires a minimal population size of $A$ to attract its specialized bee pollinator and its population growth is directly related to pollinator visitation, its population dynamics can be described using the below differential equation:

$$
\frac{dN}{dt} = rN(1-\frac{N}{K})(\frac{N}{A}-1)
$$

where $0 < A < K$. The term $A$ represents "Allee threshold", below which the population growth rate is negative (because of no visiting pollinators) and thus the population will decline; $r$ is the intrinsic rate of increase and $K$ is the carrying capacity.

(1) You can calculate the equilibrium population sizes and use the graphical method to determine their stability. The equilibrium population sizes are $N^* = 0$ (stable), $N^* = A$ (unstable), and $N^* = K$ (stable).

```{r}
r = 1
A = 150
K = 500
curve(r*x*(1-x/K)*(x/A-1), from = 0, to = 550, xlim = c(0, 550),
      xlab = "N", ylab = "dN/dt", las = 1)
abline(h = 0, lty = 2)
points(y = rep(0, 3), x = c(0, A, K), pch = c(16, 1, 16))
text(x = c(0, A, K), y = rep(20, 3), labels = c("0", "A", "K"), font = 3, col = "blue")
arrows(x0 = c(100, 200, 550), y0 = -10, x1 = c(10, 450, 510), y1 = -10, length = 0.08, lwd = 2)
```

(2) Simulate the dynamics with an intrinsic rate of increase of $r$ = 1.2, the carrying capacity of $K$ = 1000, and the minimal threshold density of $A$ = 150. Observe the population trajectories to see how different initial population sizes can lead to different equilibrium population sizes (a phenomenon known as "alternative stable states").

```{r}
library(deSolve)
Allee <- function(t, state, pars) {
  with(as.list(c(state, pars)), {
    dN_dt = r*N*(1-N/K)*(N/A-1)
    return(list(c(dN_dt)))
    })
}
t <- seq(0, 7, by = 0.01)

state <- c(120,180, 300, 600, 900, 1200)
names(state) <- rep("N", time = length(state))
pars <- c(r = 1.2, A = 150, K = 1000)
par(mar = c(5, 4+2, 4,2) + 0.1)

for(i in 1:length(state)){
  #runthe ode solver
  pop_size <- ode(func = Allee, t = t, y = state[i], par = pars)
  plot(pop_size,ann = F, las =T, ylim = c(0, 1500), xlim = c(0.2,7))
  par(new = TRUE)
}
abline(h = 1000, col = "red", lty = 2)
abline(h = 150, col = "red", lty = 2)
axis(side = 2, at = 150, las = T)
title(main = paste0("Allee effect\n(r = ",pars["r"],
                  ", A = ",pars["A"],
                  ", K = ",pars["K"], ")"),
      xlab = "Time")
title(ylab = "Numberof individuals", line = 4)
```

<!--chapter:end:03_Week_3_NewLogistic.Rmd-->

# Week 4 - Discrete exponential and logistic models{-} 

**Part 1 - Model the discrete logistic population growth using for loops**
Model:
\[
N_{t+1} = N_t(1+r(1-\frac{N_t}{K}))
\]

```{r}
### (1) Define the discrete logistic growth equation
log_fun <- function(r, N, K){N + r*N*(1-N/K)}
```

You may modify $r$ to see the change in stability of equilibrium $K$.
```{r}
### (2) Set the parameters
r <- 1.8
K <- 200
N0 <- 10
time <- 100
Parms <- c(r = r, K = K)

### (3) Use for loop to iterate over the time sequence
pop_size <- data.frame(times = 1:time)
pop_size$N[1] <- N0
for(i in 2:time){
  pop_size$N[i] <- log_fun(r = r, N = pop_size$N[i - 1], K = K)
}

### (4) Population trajectory
plot(N ~ times, data = pop_size, type = "l")
abline(h = K, col = "red")
points(N ~ times, data = pop_size)
```

**Part 2 - Generic cobweb**

```{r}
###### Part 2: Generic cobweb
### (1) define function
ReturnMap <- function(Func, x0, times, xmax, curve_n = 1000, parms){
  
  # get time series iteration
  x <- rep(x0, times)
  for(i in 2:times){
    x[i] <- Func(x[i-1], parms)
  }
  
  # get fine grid for function curve
  x.grid <- seq(0, xmax, length.out = curve_n)
  y.grid <- Func(x.grid, parms)
  ymax <- max(y.grid, xmax)
  
  # create canvas
  plot(NA, xlim = c(0, xmax), ylim = c(0, ymax), xaxs = "i", yaxs = "i", bty = "l", 
       xlab = expression(N[t]), ylab = expression(N[t+1]))
  abline(a = 0, b = 1, lty = 2, col = "grey50")          
  lines(x.grid, y.grid, col = "steelblue", lwd = 2)      
  
  # cobweb (horizontal to diagonal, vertical up to function)
  segments(x0 = x[1], y0 = 0,   x1 = x[1],   y1 = x[2], col = "firebrick")
  for(i in 2:(times-1)){
    segments(x0 = x[i-1], y0 = x[i],   
             x1 = x[i],   y1 = x[i], col = "firebrick")
    segments(x0 = x[i],   y0 = x[i], 
             x1 = x[i],   y1 = x[i+1], col = "firebrick")
  }
  
}

### (2) Set up discrete logistic function with outside parameters
Logistic <- function(N, parms){
  with(as.list(parms), {
    return(N + r*N*(1-N/K))
  })
}
Parms <- c(r = r, K = K)

### (3) Use the ReturnMap function
ReturnMap(Func = Logistic,
          x0 = 10, 
          times = 150,
          xmax = 310,
          curve_n = 1000, 
          parms = Parms)
```

<br>


Here is a shiny app for the discrete logistic growth model. 

```{r, out.width="800px", echo = F}
knitr::include_app("https://genchanghsu0115.shinyapps.io/Discrete_logistic_mod_shinyapp/", height = "750px")
```
Credit to [Gen-Chang Hsu](https://genchanghsu.github.io/index.html)


**Part 3 - Bifurcation**

```{r}
##### Part 3: Logistic map and bifurcation
### (1) Define the function
RickerPlot <- function(Func, variable, var_vec, x0, times, x_print = 200, parms){
  
  # prepare saving space 
  data_plot <- data.frame(var = rep(var_vec, each = x_print), x = 0)
  
  # change bifurcation parameter
  for (k in 1:length(var_vec)){
    parms[variable] <- var_vec[k]
    x <- rep(x0, times)
    
    # get time series with new bifurcation parameter
    for(i in 2:times){
      x[i] <- Func(x[i-1], parms)
    }
    
    # save the data
    data_plot$x[(1 + (k - 1)*x_print):(k*x_print)] <- x[(times - x_print + 1):times]
  }
  
  # plot 
  plot(x ~ var, data = data_plot, cex = 0.05, pch = 20, 
       xlab = variable, ylab = "Population size")
  
}

#### Discrete logistic function with outside parameters
Logistic <- function(N, parms){
  with(as.list(parms), {
    return(N + r*N*(1-N/K))
  })
}

### (2) Parameter setting
Parms <- c(r = r, K = K)
r_seq <- seq(from = 1.8, to = 3, by = 0.001)

### (3) Use generic ricker plot function
RickerPlot(Func = Logistic, 
           variable = "r", 
           var_vec = r_seq, 
           x0 = 10, 
           times = 500, 
           x_print = 100, 
           parms = Parms)

```



<!--chapter:end:04_Week_4_Discrete.Rmd-->

---
output:
  html_document: default
  pdf_document: default
---
# Week 5 - Metapopulations and patch occupancy models {.unnumbered}

    Plants can condition nearby soil microbial communities, which will in turn influence the performance of subsequent colonizing plants. The soil beneath plant communities are therefore a mosaic with different cultivation histories. Po-Ju wants to understand how plant demographic rates (i.e., colonization and mortality rate) and microbial dynamics (i.e., the conditioning and decay rate of microbial communities) affect the percentage of different soil types in natural forests. As a starting point, Po-Ju builds a one-species patch occupancy model to track the dynamics of different types of plant-soil combination.

    In this model, he characterizes sites by their plant-soil microbe state, using the notation $P_{ij}$ to indicate sites that are now occupied by plant species $i$ but have soil microbes state $j$. Here, as a single species model, $i$ can be 0 or $A$, representing uncolonized sites or sites colonized by plant $A$, respectively. Similarly, $j$ can be 0 or $A$, indicating sites without recent plant conditioning history or sites conditioned by plant $A$, respectively. In summary:

1.  $P_{00}$ represents uncolonized and unconditioned sites
2.  $P_{A0}$ represents cites colonized by plant $A$ but the soil is yet to be conditioned
3.  $P_{AA}$ represents plant $A$ colonizing a site with plant-$A$-specific microbial community
4.  $P_{0A}$ represents sites that are currently unoccupied but have soil microbes that were associated with plant $A$

At the landscape scale, $P_{ij}$ represents the proportion of sites belonging to a particular plant-soil microbe state, and its dynamics, $\frac {dP_{ij}}{dt}$, summarizes the processes of plant colonization and death. The transitions between different plant-soil microbe states can be described by the following figure.

<img src="./Plant_soil_model.png" width="100%"/>

Here, $P_{00}$ can be colonized by plant $A$ when propagules arrive (per capita rate $r_{A}$), transitioning the state from $P_{00}$ to $P_{A0}$. Plants may die, with rate $m_{A}$, before conditioning the soil (i.e., transition from $P_{A0}$ back to $P_{00}$), or may successfully condition the soil with rate $c_{A}$ (i.e., transition from $P_{A0}$ to $P_{AA}$). After plants within the state $P_{AA}$ die, a site with microbial legacy is left behind, denoted as $P_{0A}$. These empty sites can be recolonized (i.e., transition from $P_{0A}$ back to $P_{AA}$) with rates affected by the microbial legacy effect, $\alpha$. Finally, the microbial community within the soil may decay to unconditioned state with rate $d_{A}$, transitioning the state from $P_{0A}$ to $P_{00}$.

    In this lab, we are going to model the dynamics of this plant-soil system. We will start by converting the flow diagram into a set of differential equations and then solve them numerically using the package `deSolve`.

```{r}
library(deSolve)
library(ggplot2)
library(tidyr)


### Model specification
PSF = function(Time, State, Pars){
  with(as.list(c(State, Pars)),{
    dP00_dt = - rA * (PA0 + PAA) * P00 + mA * PA0 + dA * P0A 
    dPA0_dt = rA * (PA0 + PAA) * P00 - cA * PA0 - mA * PA0
    dPAA_dt = cA * PA0 + alpha * rA * (PA0 + PAA) * P0A - mA * PAA
    dP0A_dt = mA * PAA - alpha * rA * (PA0 + PAA) * P0A - dA * P0A
    return(list(c(dP00_dt, dPA0_dt, dPAA_dt, dP0A_dt)))
  })
}


#### Set simulation parameters with the 'quick simulation parameters'
pars = c(rA = 0.5,
         mA = 0.1,
         cA = 0.5,
         dA = 0.4,
         alpha = 0.3)


#### Set initial condition and time steps
times = seq(0, 100, by = 0.1)
ini = c(P00 = 0.75, PA0 = 0.1, PAA = 0.05, P0A = 0.1)


#### Run the simulation
pop_size = ode(func = PSF, y = ini, parms = pars, times = times)


#### Check if simulations reached stable point 
tail(pop_size)
rowSums(tail(pop_size[, -1]))

```

    After checking the outcomes of our numerical simulation, we can visualize the system dynamics through time, using any method you prefer. The following are some examples:

Visualization of the system dynamics through time using function `matplot`.

```{r}

#### Plot (matplot)
matplot(x = pop_size[, 1], y = pop_size[, 2:5], type = "l")

```

Visualization of the system dynamics through time using base R, with axis labels and given line colors.

```{r}

#### Plot (base R)
plot(x = range(times), y = c(0,1), type = "n", xlab = "Time", ylab = "Proportion")
lines(P00 ~ time, data = pop_size, col = "black")
lines(PA0 ~ time, data = pop_size, col = "blue")
lines(PAA ~ time, data = pop_size, col = "purple")
lines(P0A ~ time, data = pop_size, col = "red")
legend("topleft", 
       legend = c("P00", "PA0", "PAA", "P0A"), 
       col = c("black", "blue", "purple", "red"), lty = 1, bty = "n")
```

Data organization using package `tidyverse` and visualization of the system dynamics through time using package `ggplot2`.


```{r}

### ggplot course website version
pop_size %>%
  as.data.frame() %>%
  gather(key = "Patch", value = "Proportion", -time) %>%
  ggplot(aes(x = time, y = Proportion, color = Patch)) +
  geom_line(linewidth = 1.5)
```


    Now we see that the system would eventually be stable, we can jump through the time series and directly take the final equilibrium point (assuming the selected simulation length works for different parameter values). Our next step is to modify the target parameter related to our research question and study their resulting outcome. For example, we want to see how the final fate of this system would change under different decay rates of the conditioned microbial effect (i.e., d_{A}, the transitioning from P_{0A} to uncolonized and unconditioned soil P_{00}). We can efficiently vary the target parameter using a for-loop to run the simulation under different decay rates.

Using for loop to run the simulation under different decay rates ($d_{A}$).

```{r}

### For-loop over different parameter values 
### Parameter range and saving space setup
dA_seq <- seq(from = 0.1, to = 0.8, by = 0.1)
Data <- as.data.frame(matrix(0, nrow = length(dA_seq), ncol = 6))
names(Data) <- c("dA", "time", "P00", "PA0", "PAA", "P0A")
Data[, 1] <- dA_seq

### Use for loop to change the parameter every time
for(i in 1:length(dA_seq)){
  
  # Set simulation parameters
  pars_new <- c(rA = 0.5, mA = 0.1, cA = 0.5, dA = dA_seq[i], alpha = 0.3)
  
  # Simulate
  pop_size_new <- ode(func = PSF, y = ini, parms = pars_new, times = times)
  
  # Save results
  Data[i, c(2:6)] <- pop_size_new[length(times), ]
}

```

Visualization of the stable state under different decay rates ($d_{A}$) using base R, with axis labels and given line colors. Does the pattern match your intuition?

```{r}
### Plot resulting equilibrium against different dA  
plot(x = range(dA_seq), y = c(0,1), type = "n", 
     xlab = "Decay rate of conditioned soil", 
     ylab = "Equilibrium proportion")
lines(P00 ~ dA, data = Data, col = "black")
lines(PA0 ~ dA, data = Data, col = "blue")
lines(PAA ~ dA, data = Data, col = "purple")
lines(P0A ~ dA, data = Data, col = "red")
legend("topleft", 
       legend = c("P00", "PA0", "PAA", "P0A"), 
       col = c("black", "blue", "purple", "red"), lty = 1, bty = "n")

```
Visualization of the stable state under different decay rates ($d_{A}$) using package `ggplot2`.

```{r}

### ggplot course website version
Data %>%
  as.data.frame() %>%
  gather(key = "Patch", value = "Proportion",-dA, -time) %>%
  ggplot(aes(x = dA, y = Proportion, color = Patch)) +
  geom_line(linewidth = 1.5)
```

<!--chapter:end:05_Week_5_MetaAfterclass.Rmd-->

# Week 6 - Harvesting and bifurcation {-}

In this lab section, we're going to analyze the budworm population
dynamic model from [**Ludwig et al.,
1978**](https://doi.org/10.2307/3939).

<br> **Part 1 - Stability of the budworm model**

In part 1 we're going to visualize the stability of the budworm model,
by plotting the differential equation. We will plot the the differential
equation with different initial, which we will see that the number and stability of equilibrium changes when parameter changes.

\[
\dfrac{dN}{dt} = rN(1 - \dfrac{N}{K}) - \dfrac{HN^2}{A^2 + N^2}
\]

```{r}
#### Plotting the functional form for different parameters
#### Parameter setting
r <- 0.055; K <- 10; H <- 0.1; A <- 1

#### Visualize the whole dN/dt with different H
N.vec <- seq(from = 0, to = 10, length = 500)
H.breaks <- c(0.05, 0.12, 0.20)
dat <- outer(X = N.vec, Y = H.breaks,
             function(N, H){r * N * (1 - N / K) - (H * N^2 / (A^2 + N^2))})
matplot(x = N.vec, y = dat, type = "l", 
        xlab = "N", ylab = "dN/dt", col = "blue", lwd = 2, las = 1)
abline(h = 0)
legend("bottomleft", legend = H.breaks, title = "H", col = "blue", lty=1:3, lwd = 2)
```
<br>

Second, we're going to plot $harvest$ rate against $N$ with
separate components of $dN/Ndt$, which the blue line is 
\[
\dfrac{HN}{A^2 + N^2}
\]
with different $H$, the red line is, 
\[
r(1 - \dfrac{N}{K})
\]
and the points that blue line and red line crosses are the equilibrium points.

```{r}
#### Visualize separate components of dN/Ndt with different H
N.vec <- seq(from = 0, to = 10, length = 500)
H.breaks <- c(0.05, 0.12, 0.20)
dat.growth <- outer(X = N.vec, Y = H.breaks,
                    function(N, H){H * N / (A^2 + N^2)}) # Note notation change
matplot(x = N.vec, y = dat.growth, type = "l", ylim = c(0, 0.10), las = 1, 
        xlab = "N", ylab = "growth / harvest rate", col = "blue", lwd = 2)
curve(r * (1 - x/K), add = T, col = "red", lwd = 2) # Just curve since its the same line, and note variable notation change
abline(h = 0)
legend("topright", legend = H.breaks, title = "H", col = "blue", lty=1:3, lwd = 2)
```
<br>


**Part 2 - Use `rootSolve` function `gradient` and `uniroot.all`, to solve stability of budworm model**

```{r}
#### Stability of the budworm model, as a function of its parameters
#### Using "rootSolve" function "gradient" and "uniroot.all"
#### Works best for simple models and those with known solutions
########################################################################################################################
library(rootSolve)
#### Parameter setting
r <- 0.055; K <- 10; H <- 0.1; A <- 1

#### Spruce budworm model for rootSolve
Budworm <- function(N, H = 0.1){
  r * N * (1 - N / K) - (H * N^2 / (A^2 + N^2))
}

#### Function of root stability
Stability <- function(H.value = 0.1){
  equilibrium <- uniroot.all(f = Budworm, interval = c(0, K), H = H.value) # finds all roots
  lambda <- vector(mode = "numeric", length = length(equilibrium))
  for(i in 1:length(equilibrium)){
    lambda[i] <- sign(gradient(f = Budworm, x = equilibrium[i], H = H.value))
  }
  return(list(Equilibrium = equilibrium,
              Lambda = lambda))
}

#### Bifurcation diagram for H
H.vec <- seq(0.001, 0.3, by = 0.0001)

## Create plotting frame
plot(0, xlim = range(H.vec), ylim = c(0, 10), type = "n", las = 1,
     xlab = "H", ylab = "Equilibrium density, N*", main = "Budworm model bifurcation along H")
legend("topright", pch = 15, pt.cex = 2, c("stable", "unstable"),
       col = c("darkblue", "lightblue"))

## Calculate number of roots and stability across range of H
for(H in H.vec){
  temp <- Stability(H.value = H)
  points(x = rep(H, length(temp$Equilibrium)),
         y = temp$Equilibrium,
         pch = 15, col = ifelse(temp$Lambda == -1, "darkblue", "lightblue"))
}
```
<br>

Take a look a this
[**website**](https://www.math.ksu.edu/~albin/teaching/math340_fall2018/slides/03_bifurcations.html) if you're interested in more details of bifurcation. 
<br>
<br>

**Extra materials**
<br>
**Using `deSolve` function `ode` to brute-force stable solution**

Here we're going to use `deSolve` to solve the budworm model,

```{r}
#### Budworm model for deSolve

library(deSolve)

BudwormODE <- function(times, state, parms) {
  with(as.list(c(state, parms)), {
    dN_dt = r * N * (1 - N / K) - (H * N^2 / (A^2 + N^2))
    return(list(c(dN_dt)))
  })
}

### Parameters setting
times <- seq(0, 5000, by = 100)
state <- c(N = 10)

#### Bifurcation diagram for H -- the forward branch
## Set first forward simulation and saving space
H.vec.forward <- seq(0.001, 0.25, by = 0.001)
parms <- c(r = 0.055, K = 10, H = H.vec.forward[1], A = 1)
temp <- ode(func = BudwormODE, times = times, y = state, parms = parms)
forward <- data.frame(H = H.vec.forward,
                      N = rep(temp[length(times), 2], length(H.vec.forward)))
## Run across forward vector, using previous step equilibrium as new initial state
for(i in 2:length(H.vec.forward)){
  state <- c(N = forward[i-1, 2] + 0.001) ## Remember to add small perturbation
  parms <- c(r = 0.055, K = 10, H = forward[i, 1], A = 1)
  temp <- ode(func = BudwormODE, times = times, y = state, parms = parms)
  forward[i, 2] = temp[length(times), 2]
}
#### Bifurcation diagram for H -- the backward branch
## Set first backward simulation and saving space
H.vec.backward <- rev(H.vec.forward)
parms <- c(r = 0.055, K = 10, H = H.vec.backward[1], A = 1)
temp <- ode(func = BudwormODE, times = times, y = state, parms = parms)
backward <- data.frame(H = H.vec.backward,
                       N = rep(temp[length(times), 2], length(H.vec.backward)))
## Run across backward vector, using previous step equilibrium as new initial state
for(i in 2:length(H.vec.backward)){
  state <- c(N = backward[i-1, 2] + 0.001)  ## Remember to add small perturbation
  parms <- c(r = 0.055, K = 10, H = backward[i, 1], A = 1)
  temp <- ode(func = BudwormODE, times = times, y = state, parms = parms)
  backward[i, 2] = temp[length(times), 2]
}

#### Plot both forward and backward branch
plot(forward[, 1], forward[, 2],
     xlim = range(H.vec.forward), ylim = c(0, 10), las = 1, pch = 1, col = "darkblue", cex = 1.6,
     xlab = "H", ylab = "Equilibrium density, N*", main = "Budworm model bifurcation along H")
points(backward[, 1], backward[, 2], pch = 16, col = "lightblue")
legend("topright", pch = c(1, 16), pt.cex = 1.5, c("forward", "backward"),
       col = c("darkblue", "lightblue"))
```
<br>

<!-- **Part 2 - Non-dimensionalized model, a 2-D bifurcation diagram** -->
<!-- <br> -->

<!-- Third, we will plot a 2-D bifurcation diagram, with $r$ against $K$,  -->
<!-- \[ -->
<!-- \dfrac{dN}{dt} = rx(1 - \dfrac{x}{K}) - \dfrac{x^2}{1 + x^2}, -->
<!-- \] -->

<!-- \[ -->
<!-- r = \dfrac{2x^3}{(1 + x^2)^2}, K = \dfrac{2x^3}{(x^2 - 1)} -->
<!-- \] -->

<!-- ```{r} -->
<!-- #### 2-D bifurcation diagram following analytical solution from Strogatz -->
<!-- #### For nondimensionalized model dx/du = rx(1-x/k) - x^2/(1+x^2) -->
<!-- #### There exist parametric curves for bifurcation points r(x) and k(x) -->
<!-- x.bifur = seq(1.001, 50, by = 0.001) -->
<!-- bifur2D = data.frame(x.bifur = x.bifur,  -->
<!--                      r.bifur = 2 * x.bifur^3 / ((1 + x.bifur^2)^2), -->
<!--                      k.bifur = 2 * x.bifur^3 / (x.bifur^2 - 1)) -->
<!-- plot(r.bifur ~ k.bifur, bifur2D, type = "l", lwd = 2, las = 1,  -->
<!--      xlim = c(0, 60), ylim = c(0, max(bifur2D$r.bifur) * 1.1),  -->
<!--      xlab = "K", ylab = "r", main = "Budworm model bifurcation along r-k space") -->
<!-- ``` -->
<!-- <br> -->

<!--chapter:end:06_Week_6_Harvesting.Rmd-->

# Week 7 - Age-structure population model{-} 

In this lab section, we will analyze a Leslie matrix using `for` loops and matrix algebra, compare the results with those obtained via eigen-analysis, and visualize the population dynamics and age distribution.

**Part 1 - Visualizing stable age distribution**

For any diagonalizable n-by-n matrix $M$ with only one dominant eigenvalue, and for any n-by-1 vector $v$, $M^tv$ will shift to the same direction with the eigenvector of $M$ corresponding to the dominant eigenvalue when $t$ is large. Here, we visualize this fact numerically.

```{r}
library(ggplot2)
Time = 6
A = matrix(c(1, 1, 0.5, 0), 2, 2, byrow=T)
N = matrix(0, Time, 2)
N[1, ] = c(1, 1)
for(i in 2:Time){
  N[i, ] = A %*% N[i-1, ]
}
Data = as.data.frame(N)
Data$Time = rep(1:Time)
Data$V1.start = 0
Data$V2.start = 0

ggplot(Data, aes(x=V1, y=V2, col=as.factor(Time))) + 
  geom_point() + 
  geom_segment(aes(x=V1.start, y=V2.start, xend=V1, yend=V2), 
               arrow=arrow(type="closed", length=unit(0.4,"cm"))) + 
  geom_text(aes(x=V1+0.1, y=V2+0.1, label=Time)) + 
  scale_color_brewer("Time", type="qual", palette=2) + 
  labs(x="Age 1", y="Age 2") +  
  theme_classic()

```


<!-- library(ggplot2) -->
<!-- set.seed(1234) -->
<!-- MAT <- matrix(rnorm(25), ncol = 5, nrow = 5) -->
<!-- abs(eigen(MAT)$values) # check only one dominant eigenvalue -->
<!-- eig_vec1 <- as.numeric(eigen(MAT)$vector[, 1]) -->
<!-- v <- rnorm(5) -->
<!-- time <- 15 -->

<!-- dat_v <- data.frame(matrix(ncol = 5, nrow = time)) -->
<!-- dat_v[1, ] <- v -->
<!-- for(i in 2:time){ -->
<!--   dat_v[i, ] <- MAT %*% t(dat_v[i-1, ]) -->
<!-- } -->

<!-- # Remake data for gganimate -->
<!-- dat <- data.frame(X1 = 0, X2 = 0, Time = 1) -->
<!-- for(i in 1:time){ -->
<!--   dat <- rbind(dat, data.frame(dat_v[i,1:2] / sqrt(sum(dat_v[i,1:2]^2)) * i, Time = i)) -->
<!--   dat <- rbind(dat, c(0,0, i+1)) -->
<!-- } -->
<!-- dat <- dat[-nrow(dat), ] -->


<!-- ggplot(dat, aes(X1, X2, color = Time)) + -->
<!--   geom_path(arrow = arrow(length = unit(0.55, "cm"))) +  -->
<!--   geom_abline(intercept = 0,  -->
<!--               slope = eig_vec1[2]/eig_vec1[1],  -->
<!--               color = "red",  -->
<!--               linetype = "dashed") # red dashed eigenvector -->



<br>

**Part 2 - Analyzing Leslie matrix**

Consider an age-strutured population model
\[
n_{t} = L^tn_0
\]
where $L$ is a Leslie matrix and $n_t = (n_{1,t}, n_{2,t}, n_{3,t})$ is the population sizes with three different ages in time $t$.
```{r}
### Leslie matrix and initial age classes
leslie <- matrix(data = c(0, 1, 5,
                          0.5, 0, 0,
                          0, 0.3, 0),
                      nrow = 3,
                      ncol = 3,
                      byrow = T)

N0 <- c(10, 1, 1)

### for loop and matrix algebra
time <- 50
pop_size <- data.frame(Age1 = rep(0, time),
                       Age2 = rep(0, time),
                       Age3 = rep(0, time))
pop_size[1, ] <- N0

for (i in 2:time) {
  # Matrix multiplication
  pop_size[i, ] <- leslie %*% t(pop_size[i-1, ])
}

# Total abundance
pop_size$N <- rowSums(pop_size)

head(pop_size)

plot(c(1,time), c(0,265), type = "n", xlab = "time", ylab = "pop_size")
lines(1:time , pop_size$Age1, col = "red")
lines(1:time , pop_size$Age2, col = "blue")
lines(1:time , pop_size$Age3, col = "green")
legend("topleft",
       legend = c("Age1", "Age2", "Age3"),
       col = c("red", "blue", "green"),
       lty = 1)
```

Plot in log-scale:
```{r}
matplot(x = 1:time, y = log(pop_size[, 1:4]), type = "l", lty = 1,
        col = c("red", "green", "blue", "black"),
        xlab = "Time", ylab = "log(population size)")
legend("bottomright", c("Age 1", "Age 2", "Age 3", "Total"), bty = "n",
       lty = 1 , col = c("red", "green", "blue", "black"))
```

By the derivation in the class, the asymptotic population sizes can be approximated by 
\[
n_t \approx c\cdot \lambda_1^t\cdot u_1
\]
where $c$ is a constant, $\lambda_1$ is the dominant eigenvalue and $u_1$ is the corresponding eigenvector. Hence, with the long-term dynamics, the population grows at a rate $\lambda_1$ and with the age distribution $u_1$. Here, we check this fact numerically.
```{r}
### Asymptotic growth rate and stable age distribution

asymptotic_growth <- pop_size$N[time]/pop_size$N[time-1]
asymptotic_growth

age_distribution <- pop_size[time, 1:3]/sum(pop_size[time, 1:3])
age_distribution

### Eigen-analysis of the Leslie matrix
EIGEN <- eigen(leslie)
EIGEN
abs(EIGEN$values[1]) # dominant eigenvalue
as.numeric(EIGEN$vectors[, 1] / sum(EIGEN$vectors[, 1])) # corresponding eigenvector
```

The asymptotic growth rate and stable age distribution obtained from for loops and eigen-analysis are similar.

<br>


**Part 3 - In-class exercise: Analyzing population matrix of common teasel**

[Common teasel (_Dipsacus sylvestris_)](https://en.wikipedia.org/wiki/Dipsacus_fullonum) is a herbaceous plant commonly found in abandoned fields and meadows in North America. It has a complex life cycle consisting of various stages. The seeds may lie dormant for one or two years. Seeds that germinate form small rosettes, which will gradually transit into medium and eventually large rosettes. These rosettes (all three sizes) may remain in the same stage for years before entering the next stage. After undergoing vernalization, large (and a few medium) rosettes will form stalks and flower in the upcoming summer, set seeds once, and die. Occasionally, the flowering plants will produce seeds that directly germinate into small/medium/large rosettes without entering dormancy.

Here is a transition diagram for the teasel. Please convert this diagram into a stage-based transition matrix (Lefkovitch matrix) and derive the asymptotic growth rate $\lambda$ in R. 

<img src="./Teasel Diagram.png" width= "100%"/>

<br>


**Part 4 - COM(P)ADRE: A global database of population matrices**

[COM(P)ADRE](https://compadre-db.org/ExploreDatabase) is an online repository containing matrix population models on hundreds of plants, animals, algae, fungi, bacteria, and viruses around the world, as well as their associated metadata. Take a look at the website: You will be exploring the population dynamics of a species (of your choice) in your assignment!

<br>

<!--chapter:end:07_Week_7_age.Rmd-->

