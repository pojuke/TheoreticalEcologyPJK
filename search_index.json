[["index.html", "Introduction to Theoretical Ecology Course information", " Introduction to Theoretical Ecology Instructor: Po-Ju Ke \\(~~~~~\\) Teaching Assistant: Guan-Yu Chen 2025 Fall at National Taiwan Univeristy Course information Description The development of theory plays an important role in advancing ecology as a scientific field. This three-unit course is for students at the graduate or advanced undergraduate level. The course will cover classic theoretical topics in population and community ecology, staring from single-species dynamics and gradually build up to multispecies models. Emphasis will be on theoretical concepts and corresponding mathematical approaches. This course is designed as a two-hour lecture (written on black board) followed by a one-hour complementary hands-on practice module. In the lecture, we will analyze dynamical models and discuss their theoretical implications. In the practice section, we will use a combination interactive applications and numerical simulations to gain more intuition of the dynamics and behavior of different models. Objective By the end of the course, students are expected to be familiar with the basic building blocks of ecological models, and would be able to formulate and analyze simple models of their own. The hands-on practice component should allow students to link their ecological intuition with the underlying mathematical model, helping them to better understand the primary literature of theoretical ecology. Requirement Students are only expected to have a basic understanding of Calculus (e.g., freshman introductory course) and Ecology. It’s OK if you’re not familiar with calculus as we will provide relevant material for you to review during the first week. Format Thursday 6,7,8 (1:20 pm ~ 4:20 pm) at Gongtong 207 Grading The final grade consists of: Assignment problem sets (60%) Midterm exam (15%) Final exam (15%) Course participation (10%) Course materials We will use a combination of textbooks of theoretical ecology. Textbook chapters and additional reading materials (listed in the course outline) will be provided. (see Syllabus for more details). Below are the textbook references: A Primer of Ecology (4th edition). Nicholas Gotelli, 2008. An Illustrated Guide to Theoretical Ecology. Ted Case, 2000. A Biologist’s Guide to Mathematical Modeling in Ecology and Evolution. Sarah Otto &amp; Troy Day, 2011. Mathematical Ecology of Populations and Ecosystems. John Pastor, 2008. Nonlinear Dynamics and Choas. Steven Strogatz, 2000. Contacts Instructor: Po-Ju Ke Office: Life Science Building R635 Email: pojuke@ntu.edu.tw Office hours: by appointment Teaching assistant: Guan-Yu Chen Office: Life Science Building R635 Email: r13b44005@ntu.edu.tw Office hours: by appointment "],["syllabus.html", "Syllabus", " Syllabus Date Lecture topic Lab Readings Week 1 9/4 Introduction: what is theoretical ecology? - Grainger et al., 2021 Week 2 9/11 Exponential population growth Solving exponential growth equation using “deSolve” &amp; Visualization Gotelli [Ch.1], Case[Ch.1] Week 3 9/18 Logistic population growth and stability analysis Simulating logistic growth - Week 4 9/25 Discrete population growth and stability analysis Logistic map and Ricker diagram Gotelli [Ch.2], Case[Ch.5], Otto &amp; Day[Ch.5], May., 1976 Week 5 10/2 Metapopulations and patch occupancy models Metapopulations and patch occupancy models Gotelli [Ch.4], Case[Ch.16] Week 6 10/9 Harvesting and bifurcation Bifurcation diagram Pastor [Ch. 7], Strogatz [Ch. 3] Week 7 10/16 Age-structured population models Age-structured population model Gotelli [Ch.3], Case[Ch.3] Week 8 10/23 Lotka-Volterra model of competition: graphical analysis Simulating competitive dynamics and invasion growth Gotelli [Ch.5], Case[Ch.14], Broekman et al., 2019 Week 9 10/30 Midterm exam - - Week 10 11/6 Lotka-Volterra model of competition: invasion analysis and linear stability analysis Visualization of dynamics with complex eigenvalues Otto &amp; Day [Ch.8], May., 1972 Week 11 11/13 Predator-prey interactions (I) Lotka-Volterra model of predator-prey interactions and time-scale separation Gotelli [Ch.6], Case[Ch.12, 13] Week 12 11/20 Predator-prey interactions (II) Rosenzweig-MacArthur predator-prey model Gotelli [Ch.6], Case[Ch.12, 13] Week 13 11/27 Multispecies models of predation: apparent competition Consumer-resource dynamics Tilman., 1980, Armstrong &amp; McGehee., 1980 Week 14 12/4 Mechanistic models for consumer-resource dynamics Parameter space for apparent competition model Holt., 1977 Week 15 12/11 Research applcations: plant-soil feedback as an example - - Week 16 12/18 Final exam - - "],["week-2---exponential-population-growth.html", "Week 2 - Exponential population growth", " Week 2 - Exponential population growth In part 1, we will solve the differential equation for exponential population growth and visualize how the population sizes change over time. Part 1 - Numerical solution using the package deSolve Two main phases: Model specification: specify the structure of differential equation model Model application: set the time steps, initial population size and model parameters (e.g., intrinsic population growth rate \\(r\\)), and then solve the equation model p span#aaa:before { content: \"(1) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } p span#bbb:before { content: \"(2) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } d-article table.lightable-paper { margin-bottom: 0px; } Consider the model \\[ \\frac{dN}{dt} = rN \\] where \\(N\\) is population size and \\(r\\) is the intrinsic growth rate. ###### part 1 ###### # install.packages(&quot;deSolve&quot;) library(deSolve) ### (1) Model specification exponential_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N # Exponential growth equation return(list(c(dN_dt))) # Return the results }) } Set the time steps, initial population size and model parameters. ### (2) Model application times &lt;- seq(0, 10, by = 0.1) # Time steps to integrate over state &lt;- c(N = 10) # Initial population size parms &lt;- c(r = 1.5) # Intrinsic growth rate Solve the equation by ode() numerically. # Run the ode solver pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Take a look at the results head(pop_size) ## time N ## [1,] 0.0 10.00000 ## [2,] 0.1 11.61834 ## [3,] 0.2 13.49860 ## [4,] 0.3 15.68313 ## [5,] 0.4 18.22120 ## [6,] 0.5 21.17002 Visualization plot(N ~ time, data = pop_size) Compare simulation result with analytic solution, which is \\[ N(t) = N_0\\exp\\{rt\\} \\] par(mfrow = c(1,2)) plot(N ~ time, data = pop_size) # Plot simulation data curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # Adding analytic solution plot(N ~ time, data = pop_size, log = &quot;y&quot;) # Plot logged simulation data curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # Adding analytic solution Part 2 - Comparing different ode solvers and different time intervals In default of ode(), the equations are solved by LSODA method. We can change the method by modifying the argument method in ode(). ###### part 2 ###### # Original setting times &lt;- seq(0, 10, by = 0.1) # Time steps to integrate over state &lt;- c(N = 10) # Initial population size parms &lt;- c(r = 1.5) # Intrinsic growth rate # Default: LSODA pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times, y = state, parms = parms, method = &quot;euler&quot;) # Compare different method par(mfrow = c(1,2)) plot(N ~ time, data = pop_size, main = &quot;LSODA&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_1, main = &quot;Euler&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve # Different time intervals times_1 &lt;- seq(0, 10, by = 1) # time steps to integrate over times_2 &lt;- seq(0, 10, by = 0.1) # time steps to integrate over times_3 &lt;- seq(0, 10, by = 0.01) # time steps to integrate over # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times_1, y = state, parms = parms, method = &quot;euler&quot;) pop_size_2 &lt;- ode(func = exponential_model, times = times_2, y = state, parms = parms, method = &quot;euler&quot;) pop_size_3 &lt;- ode(func = exponential_model, times = times_3, y = state, parms = parms, method = &quot;euler&quot;) # Compare different time intervals par(mfrow = c(1,3)) plot(N ~ time, data = pop_size_1, main = &quot;Time intervals = 1&quot;) curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_2, main = &quot;Time intervals = 0.1&quot;) curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_3, main = &quot;Time intervals = 0.01&quot;) curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # correct curve Part 3 - Solving exponential growth model with fluctuating growth rate Consider the model \\[ \\frac{dN}{dt} = r(t)N \\ \\text{, } r(t) = \\overline{r} + \\sigma\\sin(\\omega t) \\] where \\(\\overline{r}\\) and \\(\\omega\\) are constants. The analytic solution of the ode model is \\[ N(t) = N_0\\exp\\{\\overline{r}t - \\frac{\\sigma}{\\omega}[\\cos(\\omega t) - 1]\\} \\] ###### part 3 ###### ### Model specification exponential_model_fluc &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = (r_bar + sigma*sin(omega*times))*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 1.5, sigma = 5, omega = 2*pi) # intrinsic growth rate Plot \\(r(t)\\) ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve plot(N ~ times, data = pop_size, log = &quot;y&quot;) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve Adjust \\(\\overline{r}\\) ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 0.1, sigma = 5, omega = 2*pi) # intrinsic growth rate ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve "],["week-3---logistic-population-growth-and-stability-analysis.html", "Week 3 - Logistic population growth and stability analysis", " Week 3 - Logistic population growth and stability analysis Part 1 - Shining app for logistic growth Credit to Gen-Chang Hsu Part 2 - Population growth with Allee effects Some populations experience negative growth rates when the population size is too low, a phenomenon known as “Allee effect”. For example, some flowering plants require a minimal local density to attract pollinators (clustering effects). Below this density, pollinators will not be able to detect the presence of flowers and therefore the plants cannot complete their life cycle. Some flower species, e.g., Itea, requires a minimal population size of \\(A\\) to attract its specialized bee pollinator and its population growth is directly related to pollinator visitation, its population dynamics can be described using the below differential equation: \\[ \\frac{dN}{dt} = rN(1-\\frac{N}{K})(\\frac{N}{A}-1) \\] where \\(0 &lt; A &lt; K\\). The term \\(A\\) represents “Allee threshold”, below which the population growth rate is negative (because of no visiting pollinators) and thus the population will decline; \\(r\\) is the intrinsic rate of increase and \\(K\\) is the carrying capacity. You can calculate the equilibrium population sizes and use the graphical method to determine their stability. The equilibrium population sizes are \\(N^* = 0\\) (stable), \\(N^* = A\\) (unstable), and \\(N^* = K\\) (stable). r = 1 A = 150 K = 500 curve(r*x*(1-x/K)*(x/A-1), from = 0, to = 550, xlim = c(0, 550), xlab = &quot;N&quot;, ylab = &quot;dN/dt&quot;, las = 1) abline(h = 0, lty = 2) points(y = rep(0, 3), x = c(0, A, K), pch = c(16, 1, 16)) text(x = c(0, A, K), y = rep(20, 3), labels = c(&quot;0&quot;, &quot;A&quot;, &quot;K&quot;), font = 3, col = &quot;blue&quot;) arrows(x0 = c(100, 200, 550), y0 = -10, x1 = c(10, 450, 510), y1 = -10, length = 0.08, lwd = 2) Simulate the dynamics with an intrinsic rate of increase of \\(r\\) = 1.2, the carrying capacity of \\(K\\) = 1000, and the minimal threshold density of \\(A\\) = 150. Observe the population trajectories to see how different initial population sizes can lead to different equilibrium population sizes (a phenomenon known as “alternative stable states”). library(deSolve) Allee &lt;- function(t, state, pars) { with(as.list(c(state, pars)), { dN_dt = r*N*(1-N/K)*(N/A-1) return(list(c(dN_dt))) }) } t &lt;- seq(0, 7, by = 0.01) state &lt;- c(120,180, 300, 600, 900, 1200) names(state) &lt;- rep(&quot;N&quot;, time = length(state)) pars &lt;- c(r = 1.2, A = 150, K = 1000) par(mar = c(5, 4+2, 4,2) + 0.1) for(i in 1:length(state)){ #runthe ode solver pop_size &lt;- ode(func = Allee, t = t, y = state[i], par = pars) plot(pop_size,ann = F, las =T, ylim = c(0, 1500), xlim = c(0.2,7)) par(new = TRUE) } abline(h = 1000, col = &quot;red&quot;, lty = 2) abline(h = 150, col = &quot;red&quot;, lty = 2) axis(side = 2, at = 150, las = T) title(main = paste0(&quot;Allee effect\\n(r = &quot;,pars[&quot;r&quot;], &quot;, A = &quot;,pars[&quot;A&quot;], &quot;, K = &quot;,pars[&quot;K&quot;], &quot;)&quot;), xlab = &quot;Time&quot;) title(ylab = &quot;Numberof individuals&quot;, line = 4) "],["week-4---discrete-exponential-and-logistic-models.html", "Week 4 - Discrete exponential and logistic models", " Week 4 - Discrete exponential and logistic models Part 1 - Model the discrete logistic population growth using for loops Model: \\[ N_{t+1} = N_t(1+r(1-\\frac{N_t}{K})) \\] ### (1) Define the discrete logistic growth equation log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} You may modify \\(r\\) to see the change in stability of equilibrium \\(K\\). ### (2) Set the parameters r &lt;- 1.8 K &lt;- 200 N0 &lt;- 10 time &lt;- 100 Parms &lt;- c(r = r, K = K) ### (3) Use for loop to iterate over the time sequence pop_size &lt;- data.frame(times = 1:time) pop_size$N[1] &lt;- N0 for(i in 2:time){ pop_size$N[i] &lt;- log_fun(r = r, N = pop_size$N[i - 1], K = K) } ### (4) Population trajectory plot(N ~ times, data = pop_size, type = &quot;l&quot;) abline(h = K, col = &quot;red&quot;) points(N ~ times, data = pop_size) Part 2 - Generic cobweb ###### Part 2: Generic cobweb ### (1) define function ReturnMap &lt;- function(Func, x0, times, xmax, curve_n = 1000, parms){ # get time series iteration x &lt;- rep(x0, times) for(i in 2:times){ x[i] &lt;- Func(x[i-1], parms) } # get fine grid for function curve x.grid &lt;- seq(0, xmax, length.out = curve_n) y.grid &lt;- Func(x.grid, parms) ymax &lt;- max(y.grid, xmax) # create canvas plot(NA, xlim = c(0, xmax), ylim = c(0, ymax), xaxs = &quot;i&quot;, yaxs = &quot;i&quot;, bty = &quot;l&quot;, xlab = expression(N[t]), ylab = expression(N[t+1])) abline(a = 0, b = 1, lty = 2, col = &quot;grey50&quot;) lines(x.grid, y.grid, col = &quot;steelblue&quot;, lwd = 2) # cobweb (horizontal to diagonal, vertical up to function) segments(x0 = x[1], y0 = 0, x1 = x[1], y1 = x[2], col = &quot;firebrick&quot;) for(i in 2:(times-1)){ segments(x0 = x[i-1], y0 = x[i], x1 = x[i], y1 = x[i], col = &quot;firebrick&quot;) segments(x0 = x[i], y0 = x[i], x1 = x[i], y1 = x[i+1], col = &quot;firebrick&quot;) } } ### (2) Set up discrete logistic function with outside parameters Logistic &lt;- function(N, parms){ with(as.list(parms), { return(N + r*N*(1-N/K)) }) } Parms &lt;- c(r = r, K = K) ### (3) Use the ReturnMap function ReturnMap(Func = Logistic, x0 = 10, times = 150, xmax = 310, curve_n = 1000, parms = Parms) Here is a shiny app for the discrete logistic growth model. Credit to Gen-Chang Hsu Part 3 - Bifurcation ##### Part 3: Logistic map and bifurcation ### (1) Define the function RickerPlot &lt;- function(Func, variable, var_vec, x0, times, x_print = 200, parms){ # prepare saving space data_plot &lt;- data.frame(var = rep(var_vec, each = x_print), x = 0) # change bifurcation parameter for (k in 1:length(var_vec)){ parms[variable] &lt;- var_vec[k] x &lt;- rep(x0, times) # get time series with new bifurcation parameter for(i in 2:times){ x[i] &lt;- Func(x[i-1], parms) } # save the data data_plot$x[(1 + (k - 1)*x_print):(k*x_print)] &lt;- x[(times - x_print + 1):times] } # plot plot(x ~ var, data = data_plot, cex = 0.05, pch = 20, xlab = variable, ylab = &quot;Population size&quot;) } #### Discrete logistic function with outside parameters Logistic &lt;- function(N, parms){ with(as.list(parms), { return(N + r*N*(1-N/K)) }) } ### (2) Parameter setting Parms &lt;- c(r = r, K = K) r_seq &lt;- seq(from = 1.8, to = 3, by = 0.001) ### (3) Use generic ricker plot function RickerPlot(Func = Logistic, variable = &quot;r&quot;, var_vec = r_seq, x0 = 10, times = 500, x_print = 100, parms = Parms) "]]
