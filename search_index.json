[["index.html", "Introduction to Theoretical Ecology Course information", " Introduction to Theoretical Ecology Instructor: Po-Ju Ke \\(~~~~~\\) Teaching Assistant: Hsiang-Chih Lo 2024 Fall at National Taiwan Univeristy Course information Description The development of theory plays an important role in advancing ecology as a scientific field. This three-unit course is for students at the graduate or advanced undergraduate level. The course will cover classic theoretical topics in population and community ecology, staring from single-species dynamics and gradually build up to multispecies models. Emphasis will be on theoretical concepts and corresponding mathematical approaches. This course is designed as a two-hour lecture (written on black board) followed by a one-hour complementary hands-on practice module. In the lecture, we will analyze dynamical models and discuss their theoretical implications. In the practice section, we will use a combination interactive applications and numerical simulations to gain more intuition of the dynamics and behavior of different models. Objective By the end of the course, students are expected to be familiar with the basic building blocks of ecological models, and would be able to formulate and analyze simple models of their own. The hands-on practice component should allow students to link their ecological intuition with the underlying mathematical model, helping them to better understand the primary literature of theoretical ecology. Requirement Students are only expected to have a basic understanding of Calculus (e.g., freshman introductory course) and Ecology. It’s OK if you’re not familiar with calculus as we will provide relevant material for you to review during the first week. Format Tuesday 6,7,8 (1:20 pm ~ 4:20 pm) at 共207 Grading The final grade consists of: Assignment problem sets (60%) Midterm exam (15%) Final exam (15%) Course participation (10%) Course materials We will use a combination of textbooks of theoretical ecology. Textbook chapters and additional reading materials (listed in the course outline) will be provided. (see Syllabus for more details). Below are the textbook references: A Primer of Ecology (4th edition). Nicholas Gotelli, 2008. An Illustrated Guide to Theoretical Ecology. Ted Case, 2000. A Biologist’s Guide to Mathematical Modeling in Ecology and Evolution. Sarah Otto &amp; Troy Day, 2011. Mathematical Ecology of Populations and Ecosystems. John Pastor, 2008. Nonlinear Dynamics and Choas. Steven Strogatz, 2000. Contacts Instructor: Po-Ju Ke Office: Life Science Building R635 Email: pojuke@ntu.edu.tw Office hours: by appointment Teaching assistant: Hsiang-Chih Lo Office: Life Science Building R635 Email: r12b44009@ntu.edu.tw Office hours: by appointment "],["syllabus.html", "Syllabus", " Syllabus Date Lecture topic Lab Readings Week 1 9/3 Introduction: what is theoretical ecology? - Grainger et al., 2021 Week 2 9/10 Exponential population growth Solving exponential growth equation using “deSolve” &amp; Visualization Gotelli [Ch.1], Case[Ch.1] Week 3 9/17 No class (National holiday) - - Week 4 9/24 Logistic population growth and stability analysis Shinny App for logistic population growth Gotelli [Ch.2], Case[Ch.5], Otto &amp; Day[Ch.5] Week 5 10/1 Age-structured population models Age-structured population model Gotelli [Ch.3], Case[Ch.3] Week 6 10/8 Metapopulations and patch occupancy models Metapopulations and patch occupancy models Gotelli [Ch.4], Case[Ch.16] Week 7 10/15 Harvesting and bifurcation Alternative stable state diagram Pastor [Ch. 7], Strogatz [Ch. 3] Week 8 10/22 Lotka-Volterra model of competition: graphical analysis Lotka-Volterra competition model - Population dynamics Gotelli [Ch.5], Case[Ch.14] Week 9 10/29 Midterm exam - - Week 10 11/5 Lotka-Volterra model of competition: invasion analysis and linear stability analysis Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues Otto &amp; Day [Ch.8], Broekman et al., 2019 Week 11 11/12 Predator-prey interactions (I) Lotka-Volterra model of predator-prey interactions and time-scale separation Gotelli [Ch.6], Case[Ch.12, 13] Week 12 11/19 Predator-prey interactions (II) + Discussion on May (1972) Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship Gotelli [Ch.6], Case[Ch.12, 13], May., 1972 Week 13 11/26 Mechanistic models for consumer-resource dynamics Parameter space for apparent competition model Tilman., 1980, Armstrong &amp; McGehee., 1980 Week 14 12/3 Multispecies models of predation: apparent competition Resource competition Holt., 1977 Week 15 12/10 Research applcations: plant-soil feedback as an example - - Week 16 12/17 Final exam - - "],["week-2---exponential-population-growth.html", "Week 2 - Exponential population growth", " Week 2 - Exponential population growth In part 1, we will solve the differential equation for exponential population growth and visualize how the population sizes change over time. Part 1 - Numerical solution using the package deSolve Two main phases: Model specification: specify the structure of differential equation model Model application: set the time steps, initial population size and model parameters (e.g., intrinsic population growth rate \\(r\\)), and then solve the equation model p span#aaa:before { content: \"(1) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } p span#bbb:before { content: \"(2) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } d-article table.lightable-paper { margin-bottom: 0px; } Consider the model \\[ \\frac{dN}{dt} = rN \\] where \\(N\\) is population size and \\(r\\) is the intrinsic growth rate. ###### part 1 ###### # install.packages(&quot;deSolve&quot;) library(deSolve) ### (1) Model specification exponential_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N # Exponential growth equation return(list(c(dN_dt))) # Return the results }) } Set the time steps, initial population size and model parameters. ### (2) Model application times &lt;- seq(0, 10, by = 0.1) # Time steps to integrate over state &lt;- c(N = 10) # Initial population size parms &lt;- c(r = 1.5) # Intrinsic growth rate Solve the equation by ode() numerically. # Run the ode solver pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Take a look at the results head(pop_size) ## time N ## [1,] 0.0 10.00000 ## [2,] 0.1 11.61834 ## [3,] 0.2 13.49860 ## [4,] 0.3 15.68313 ## [5,] 0.4 18.22120 ## [6,] 0.5 21.17002 Visualization plot(N ~ time, data = pop_size) Compare simulation result with analytic solution, which is \\[ N(t) = N_0\\exp\\{rt\\} \\] par(mfrow = c(1,2)) plot(N ~ time, data = pop_size) # Plot simulation data curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # Adding analytic solution plot(N ~ time, data = pop_size, log = &quot;y&quot;) # Plot logged simulation data curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # Adding analytic solution Part 2 - Comparing different ode solvers and different time intervals In default of ode(), the equations are solved by LSODA method. We can change the method by modifying the argument method in ode(). ###### part 2 ###### # Original setting times &lt;- seq(0, 10, by = 0.1) # Time steps to integrate over state &lt;- c(N = 10) # Initial population size parms &lt;- c(r = 1.5) # Intrinsic growth rate # Default: LSODA pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times, y = state, parms = parms, method = &quot;euler&quot;) # Compare different method par(mfrow = c(1,2)) plot(N ~ time, data = pop_size, main = &quot;LSODA&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_1, main = &quot;Euler&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve # Different time intervals times_1 &lt;- seq(0, 10, by = 1) # time steps to integrate over times_2 &lt;- seq(0, 10, by = 0.1) # time steps to integrate over times_3 &lt;- seq(0, 10, by = 0.01) # time steps to integrate over # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times_1, y = state, parms = parms, method = &quot;euler&quot;) pop_size_2 &lt;- ode(func = exponential_model, times = times_2, y = state, parms = parms, method = &quot;euler&quot;) pop_size_3 &lt;- ode(func = exponential_model, times = times_3, y = state, parms = parms, method = &quot;euler&quot;) # Compare different time intervals par(mfrow = c(1,3)) plot(N ~ time, data = pop_size_1, main = &quot;Time intervals = 1&quot;) curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_2, main = &quot;Time intervals = 0.1&quot;) curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_3, main = &quot;Time intervals = 0.01&quot;) curve(state[1]*exp(parms[1]*x), col = &quot;red&quot;, add = T) # correct curve Part 3 - Solving exponential growth model with fluctuating growth rate Consider the model \\[ \\frac{dN}{dt} = r(t)N \\ \\text{, } r(t) = \\overline{r} + \\sigma\\sin(\\omega t) \\] where \\(\\overline{r}\\) and \\(\\omega\\) are constants. The analytic solution of the ode model is \\[ N(t) = N_0\\exp\\{\\overline{r}t - \\frac{\\sigma}{\\omega}[\\cos(\\omega t) - 1]\\} \\] ###### part 3 ###### ### Model specification exponential_model_fluc &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = (r_bar + sigma*sin(omega*times))*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 1.5, sigma = 5, omega = 2*pi) # intrinsic growth rate Plot \\(r(t)\\) ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve plot(N ~ times, data = pop_size, log = &quot;y&quot;) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve Adjust \\(\\overline{r}\\) ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 0.1, sigma = 5, omega = 2*pi) # intrinsic growth rate ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve "],["week-4---logistic-population-growth-and-stability-analysis.html", "Week 4 - Logistic population growth and stability analysis", " Week 4 - Logistic population growth and stability analysis Credit to Gen-Chang Hsu Extra materials - Modeling discrete logistic models using for loops Model: \\[ N_{t+1} = N_t(1+r(1-\\frac{N_t}{K})) \\] ### (1) Define the discrete logistic growth equation log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} You may modify \\(r\\) to see the change in stability of equilibrium \\(K\\). ### (2) Set the parameters r &lt;- 1.8 K &lt;- 500 N0 &lt;- 10 time &lt;- 100 ### (3) Use for loop to iterate over the time sequence pop_size &lt;- data.frame(times = 1:time) pop_size$N[1] &lt;- N0 head(pop_size) ## times N ## 1 1 10 ## 2 2 10 ## 3 3 10 ## 4 4 10 ## 5 5 10 ## 6 6 10 for(i in 2:time){ pop_size$N[i] &lt;- log_fun(r = r, N = pop_size$N[i - 1], K = K) } head(pop_size) ## times N ## 1 1 10.00000 ## 2 2 27.64000 ## 3 3 74.64171 ## 4 4 188.93980 ## 5 5 400.51775 ## 6 6 543.95762 ### (4) Population trajectory plot(N ~ times, data = pop_size, type = &quot;l&quot;) abline(h = K, col = &quot;red&quot;) points(N ~ times, data = pop_size) Here is a shiny app for the discrete logistic growth model. Credit to Gen-Chang Hsu "],["week-5---metapopulations-and-patch-occupancy-models.html", "Week 5 - Metapopulations and patch occupancy models", " Week 5 - Metapopulations and patch occupancy models     Plants can condition nearby soil microbial communities, which will in turn influence the performance of subsequent colonizing plants. The soil beneath plant communities are therefore a mosaic with different cultivation histories. Po-Ju wants to understand how plant demographic rates (i.e., colonization and mortality rate) and microbial dynamics (i.e., the conditioning and decay rate of microbial communities) affect the percentage of different soil types in natural forests. As a starting point, Po-Ju builds a one-species patch occupancy model to track the dynamics of different types of plant-soil combination.     In this model, he characterizes sites by their plant-soil microbe state, using the notation \\(P_{ij}\\) to indicate sites that are now occupied by plant species \\(i\\) but have soil microbes state \\(j\\). Here, as a single species model, \\(i\\) can be 0 or \\(A\\), representing uncolonized sites or sites colonized by plant \\(A\\), respectively. Similarly, \\(j\\) can be 0 or \\(A\\), indicating sites without recent plant conditioning history or sites conditioned by plant \\(A\\), respectively. In summary: \\(P_{00}\\) represents uncolonized and unconditioned sites \\(P_{A0}\\) represents cites colonized by plant \\(A\\) but the soil is yet to be conditioned \\(P_{AA}\\) represents plant \\(A\\) colonizing a site with plant-\\(A\\)-specific microbial community \\(P_{0A}\\) represents sites that are currently unoccupied but have soil microbes that were associated with plant \\(A\\) At the landscape scale, \\(P_{ij}\\) represents the proportion of sites belonging to a particular plant-soil microbe state, and its dynamics, \\(\\frac {dP_{ij}}{dt}\\), summarizes the processes of plant colonization and death. The transitions between different plant-soil microbe states can be described by the following figure. Here, \\(P_{00}\\) can be colonized by plant \\(A\\) when propagules arrive (per capita rate \\(r_{A}\\)), transitioning the state from \\(P_{00}\\) to \\(P_{A0}\\). Plants may die, with rate \\(m_{A}\\), before conditioning the soil (i.e., transition from \\(P_{A0}\\) back to \\(P_{00}\\)), or may successfully condition the soil with rate \\(c_{A}\\) (i.e., transition from \\(P_{A0}\\) to \\(P_{AA}\\)). After plants within the state \\(P_{AA}\\) die, a site with microbial legacy is left behind, denoted as \\(P_{0A}\\). These empty sites can be recolonized (i.e., transition from \\(P_{0A}\\) back to \\(P_{AA}\\)) with rates affected by the microbial legacy effect, \\(\\alpha\\). Finally, the microbial community within the soil may decay to unconditioned state with rate \\(d_{A}\\), transitioning the state from \\(P_{0A}\\) to \\(P_{00}\\).     In this lab, we are going to model the dynamics of this plant-soil system. We will start by converting the flow diagram into a set of differential equations and then solve them numerically using the package deSolve. library(deSolve) library(ggplot2) library(tidyr) ### Model specification PSF = function(Time, State, Pars){ with(as.list(c(State, Pars)),{ dP00_dt = - rA * (PA0 + PAA) * P00 + mA * PA0 + dA * P0A dPA0_dt = rA * (PA0 + PAA) * P00 - cA * PA0 - mA * PA0 dPAA_dt = cA * PA0 + alpha * rA * (PA0 + PAA) * P0A - mA * PAA dP0A_dt = mA * PAA - alpha * rA * (PA0 + PAA) * P0A - dA * P0A return(list(c(dP00_dt, dPA0_dt, dPAA_dt, dP0A_dt))) }) } #### Set simulation parameters with the &#39;quick simulation parameters&#39; pars = c(rA = 0.5, mA = 0.1, cA = 0.5, dA = 0.4, alpha = 0.3) #### Set initial condition and time steps times = seq(0, 100, by = 0.1) ini = c(P00 = 0.75, PA0 = 0.1, PAA = 0.05, P0A = 0.1) #### Run the simulation pop_size = ode(func = PSF, y = ini, parms = pars, times = times) #### Check if simulations reached stable point tail(pop_size) ## time P00 PA0 PAA P0A ## [996,] 99.5 0.1634825 0.09738004 0.6174124 0.1217251 ## [997,] 99.6 0.1634825 0.09738004 0.6174124 0.1217251 ## [998,] 99.7 0.1634825 0.09738004 0.6174124 0.1217251 ## [999,] 99.8 0.1634825 0.09738004 0.6174124 0.1217251 ## [1000,] 99.9 0.1634825 0.09738004 0.6174124 0.1217251 ## [1001,] 100.0 0.1634825 0.09738004 0.6174124 0.1217251 rowSums(tail(pop_size[, -1])) ## [996,] [997,] [998,] [999,] [1000,] [1001,] ## 1 1 1 1 1 1     After checking the outcomes of our numerical simulation, we can visualize the system dynamics through time, using any method you prefer. The following are some examples: Visualization of the system dynamics through time using function matplot. #### Plot (matplot) matplot(x = pop_size[, 1], y = pop_size[, 2:5], type = &quot;l&quot;) Visualization of the system dynamics through time using base R, with axis labels and given line colors. #### Plot (base R) plot(x = range(times), y = c(0,1), type = &quot;n&quot;, xlab = &quot;Time&quot;, ylab = &quot;Proportion&quot;) lines(P00 ~ time, data = pop_size, col = &quot;black&quot;) lines(PA0 ~ time, data = pop_size, col = &quot;blue&quot;) lines(PAA ~ time, data = pop_size, col = &quot;purple&quot;) lines(P0A ~ time, data = pop_size, col = &quot;red&quot;) legend(&quot;topleft&quot;, legend = c(&quot;P00&quot;, &quot;PA0&quot;, &quot;PAA&quot;, &quot;P0A&quot;), col = c(&quot;black&quot;, &quot;blue&quot;, &quot;purple&quot;, &quot;red&quot;), lty = 1, bty = &quot;n&quot;) Data organization using package tidyverse and visualization of the system dynamics through time using package ggplot2. ### ggplot course website version pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Patch&quot;, value = &quot;Proportion&quot;, -time) %&gt;% ggplot(aes(x = time, y = Proportion, color = Patch)) + geom_line(linewidth = 1.5)     Now we see that the system would eventually be stable, we can jump through the time series and directly take the final equilibrium point (assuming the selected simulation length works for different parameter values). Our next step is to modify the target parameter related to our research question and study their resulting outcome. For example, we want to see how the final fate of this system would change under different decay rates of the conditioned microbial effect (i.e., d_{A}, the transitioning from P_{0A} to uncolonized and unconditioned soil P_{00}). We can efficiently vary the target parameter using a for-loop to run the simulation under different decay rates. Using for loop to run the simulation under different decay rates (\\(d_{A}\\)). ### For-loop over different parameter values ### Parameter range and saving space setup dA_seq &lt;- seq(from = 0.1, to = 0.8, by = 0.1) Data &lt;- as.data.frame(matrix(0, nrow = length(dA_seq), ncol = 6)) names(Data) &lt;- c(&quot;dA&quot;, &quot;time&quot;, &quot;P00&quot;, &quot;PA0&quot;, &quot;PAA&quot;, &quot;P0A&quot;) Data[, 1] &lt;- dA_seq ### Use for loop to change the parameter every time for(i in 1:length(dA_seq)){ # Set simulation parameters pars_new &lt;- c(rA = 0.5, mA = 0.1, cA = 0.5, dA = dA_seq[i], alpha = 0.3) # Simulate pop_size_new &lt;- ode(func = PSF, y = ini, parms = pars_new, times = times) # Save results Data[i, c(2:6)] &lt;- pop_size_new[length(times), ] } Visualization of the stable state under different decay rates (\\(d_{A}\\)) using base R, with axis labels and given line colors. Does the pattern match your intuition? ### Plot resulting equilibrium against different dA plot(x = range(dA_seq), y = c(0,1), type = &quot;n&quot;, xlab = &quot;Decay rate of conditioned soil&quot;, ylab = &quot;Equilibrium proportion&quot;) lines(P00 ~ dA, data = Data, col = &quot;black&quot;) lines(PA0 ~ dA, data = Data, col = &quot;blue&quot;) lines(PAA ~ dA, data = Data, col = &quot;purple&quot;) lines(P0A ~ dA, data = Data, col = &quot;red&quot;) legend(&quot;topleft&quot;, legend = c(&quot;P00&quot;, &quot;PA0&quot;, &quot;PAA&quot;, &quot;P0A&quot;), col = c(&quot;black&quot;, &quot;blue&quot;, &quot;purple&quot;, &quot;red&quot;), lty = 1, bty = &quot;n&quot;) Visualization of the stable state under different decay rates (\\(d_{A}\\)) using package ggplot2. ### ggplot course website version Data %&gt;% as.data.frame() %&gt;% gather(key = &quot;Patch&quot;, value = &quot;Proportion&quot;,-dA, -time) %&gt;% ggplot(aes(x = dA, y = Proportion, color = Patch)) + geom_line(linewidth = 1.5) "],["week-6---harvesting-and-bifurcation.html", "Week 6 - Harvesting and bifurcation", " Week 6 - Harvesting and bifurcation In this lab section, we’re going to analyze the budworm population dynamic model from Ludwig et al., 1978. Part 1 - Stability of the budworm model In part 1 we’re going to visualize the stability of the budworm model, by plotting the differential equation. We will plot the the differential equation with different initial, which we will see that the number and stability of equilibrium changes when parameter changes. \\[ \\dfrac{dN}{dt} = rN(1 - \\dfrac{N}{K}) - \\dfrac{HN^2}{A^2 + N^2} \\] #### Plotting the functional form for different parameters #### Parameter setting r &lt;- 0.055; K &lt;- 10; H &lt;- 0.1; A &lt;- 1 #### Visualize the whole dN/dt with different H N.vec &lt;- seq(from = 0, to = 10, length = 500) H.breaks &lt;- c(0.05, 0.12, 0.20) dat &lt;- outer(X = N.vec, Y = H.breaks, function(N, H){r * N * (1 - N / K) - (H * N^2 / (A^2 + N^2))}) matplot(x = N.vec, y = dat, type = &quot;l&quot;, xlab = &quot;N&quot;, ylab = &quot;dN/dt&quot;, col = &quot;blue&quot;, lwd = 2, las = 1) abline(h = 0) legend(&quot;bottomleft&quot;, legend = H.breaks, title = &quot;H&quot;, col = &quot;blue&quot;, lty=1:3, lwd = 2) Second, we’re going to plot \\(harvest\\) rate against \\(N\\) with separate components of \\(dN/Ndt\\), which the blue line is \\[ \\dfrac{HN}{A^2 + N^2} \\] with different \\(H\\), the red line is, \\[ r(1 - \\dfrac{N}{K}) \\] and the points that blue line and red line crosses are the equilibrium points. #### Visualize separate components of dN/Ndt with different H N.vec &lt;- seq(from = 0, to = 10, length = 500) H.breaks &lt;- c(0.05, 0.12, 0.20) dat.growth &lt;- outer(X = N.vec, Y = H.breaks, function(N, H){H * N / (A^2 + N^2)}) # Note notation change matplot(x = N.vec, y = dat.growth, type = &quot;l&quot;, ylim = c(0, 0.10), las = 1, xlab = &quot;N&quot;, ylab = &quot;growth / harvest rate&quot;, col = &quot;blue&quot;, lwd = 2) curve(r * (1 - x/K), add = T, col = &quot;red&quot;, lwd = 2) # Just curve since its the same line, and note variable notation change abline(h = 0) legend(&quot;topright&quot;, legend = H.breaks, title = &quot;H&quot;, col = &quot;blue&quot;, lty=1:3, lwd = 2) Part 2 - Use rootSolve function gradient and uniroot.all, to solve stability of budworm model #### Stability of the budworm model, as a function of its parameters #### Using &quot;rootSolve&quot; function &quot;gradient&quot; and &quot;uniroot.all&quot; #### Works best for simple models and those with known solutions ######################################################################################################################## library(rootSolve) #### Parameter setting r &lt;- 0.055; K &lt;- 10; H &lt;- 0.1; A &lt;- 1 #### Spruce budworm model for rootSolve Budworm &lt;- function(N, H = 0.1){ r * N * (1 - N / K) - (H * N^2 / (A^2 + N^2)) } #### Function of root stability Stability &lt;- function(H.value = 0.1){ equilibrium &lt;- uniroot.all(f = Budworm, interval = c(0, K), H = H.value) # finds all roots lambda &lt;- vector(mode = &quot;numeric&quot;, length = length(equilibrium)) for(i in 1:length(equilibrium)){ lambda[i] &lt;- sign(gradient(f = Budworm, x = equilibrium[i], H = H.value)) } return(list(Equilibrium = equilibrium, Lambda = lambda)) } #### Bifurcation diagram for H H.vec &lt;- seq(0.001, 0.3, by = 0.0001) ## Create plotting frame plot(0, xlim = range(H.vec), ylim = c(0, 10), type = &quot;n&quot;, las = 1, xlab = &quot;H&quot;, ylab = &quot;Equilibrium density, N*&quot;, main = &quot;Budworm model bifurcation along H&quot;) legend(&quot;topright&quot;, pch = 15, pt.cex = 2, c(&quot;stable&quot;, &quot;unstable&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;)) ## Calculate number of roots and stability across range of H for(H in H.vec){ temp &lt;- Stability(H.value = H) points(x = rep(H, length(temp$Equilibrium)), y = temp$Equilibrium, pch = 15, col = ifelse(temp$Lambda == -1, &quot;darkblue&quot;, &quot;lightblue&quot;)) } Take a look a this website if you’re interested in more details of bifurcation. Extra materials Using deSolve function ode to brute-force stable solution Here we’re going to use deSolve to solve the budworm model, #### Budworm model for deSolve library(deSolve) BudwormODE &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r * N * (1 - N / K) - (H * N^2 / (A^2 + N^2)) return(list(c(dN_dt))) }) } ### Parameters setting times &lt;- seq(0, 5000, by = 100) state &lt;- c(N = 10) #### Bifurcation diagram for H -- the forward branch ## Set first forward simulation and saving space H.vec.forward &lt;- seq(0.001, 0.25, by = 0.001) parms &lt;- c(r = 0.055, K = 10, H = H.vec.forward[1], A = 1) temp &lt;- ode(func = BudwormODE, times = times, y = state, parms = parms) forward &lt;- data.frame(H = H.vec.forward, N = rep(temp[length(times), 2], length(H.vec.forward))) ## Run across forward vector, using previous step equilibrium as new initial state for(i in 2:length(H.vec.forward)){ state &lt;- c(N = forward[i-1, 2] + 0.001) ## Remember to add small perturbation parms &lt;- c(r = 0.055, K = 10, H = forward[i, 1], A = 1) temp &lt;- ode(func = BudwormODE, times = times, y = state, parms = parms) forward[i, 2] = temp[length(times), 2] } #### Bifurcation diagram for H -- the backward branch ## Set first backward simulation and saving space H.vec.backward &lt;- rev(H.vec.forward) parms &lt;- c(r = 0.055, K = 10, H = H.vec.backward[1], A = 1) temp &lt;- ode(func = BudwormODE, times = times, y = state, parms = parms) backward &lt;- data.frame(H = H.vec.backward, N = rep(temp[length(times), 2], length(H.vec.backward))) ## Run across backward vector, using previous step equilibrium as new initial state for(i in 2:length(H.vec.backward)){ state &lt;- c(N = backward[i-1, 2] + 0.001) ## Remember to add small perturbation parms &lt;- c(r = 0.055, K = 10, H = backward[i, 1], A = 1) temp &lt;- ode(func = BudwormODE, times = times, y = state, parms = parms) backward[i, 2] = temp[length(times), 2] } #### Plot both forward and backward branch plot(forward[, 1], forward[, 2], xlim = range(H.vec.forward), ylim = c(0, 10), las = 1, pch = 1, col = &quot;darkblue&quot;, cex = 1.6, xlab = &quot;H&quot;, ylab = &quot;Equilibrium density, N*&quot;, main = &quot;Budworm model bifurcation along H&quot;) points(backward[, 1], backward[, 2], pch = 16, col = &quot;lightblue&quot;) legend(&quot;topright&quot;, pch = c(1, 16), pt.cex = 1.5, c(&quot;forward&quot;, &quot;backward&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;)) "],["week-7---age-structure-population-model.html", "Week 7 - Age-structure population model", " Week 7 - Age-structure population model In this lab section, we will analyze a Leslie matrix using for loops and matrix algebra, compare the results with those obtained via eigen-analysis, and visualize the population dynamics and age distribution. Part 1 - Visualizing stable age distribution For any diagonalizable n-by-n matrix \\(M\\) with only one dominant eigenvalue, and for any n-by-1 vector \\(v\\), \\(M^tv\\) will shift to the same direction with the eigenvector of \\(M\\) corresponding to the dominant eigenvalue when \\(t\\) is large. Here, we visualize this fact numerically. library(ggplot2) Time = 6 A = matrix(c(1, 1, 0.5, 0), 2, 2, byrow=T) N = matrix(0, Time, 2) N[1, ] = c(1, 1) for(i in 2:Time){ N[i, ] = A %*% N[i-1, ] } Data = as.data.frame(N) Data$Time = rep(1:Time) Data$V1.start = 0 Data$V2.start = 0 ggplot(Data, aes(x=V1, y=V2, col=as.factor(Time))) + geom_point() + geom_segment(aes(x=V1.start, y=V2.start, xend=V1, yend=V2), arrow=arrow(type=&quot;closed&quot;, length=unit(0.4,&quot;cm&quot;))) + geom_text(aes(x=V1+0.1, y=V2+0.1, label=Time)) + scale_color_brewer(&quot;Time&quot;, type=&quot;qual&quot;, palette=2) + labs(x=&quot;Age 1&quot;, y=&quot;Age 2&quot;) + theme_classic() Part 2 - Analyzing Leslie matrix Consider an age-strutured population model \\[ n_{t} = L^tn_0 \\] where \\(L\\) is a Leslie matrix and \\(n_t = (n_{1,t}, n_{2,t}, n_{3,t})\\) is the population sizes with three different ages in time \\(t\\). ### Leslie matrix and initial age classes leslie &lt;- matrix(data = c(0, 1, 5, 0.5, 0, 0, 0, 0.3, 0), nrow = 3, ncol = 3, byrow = T) N0 &lt;- c(10, 0, 0) ### for loop and matrix algebra time &lt;- 50 pop_size &lt;- data.frame(Age1 = rep(0, time), Age2 = rep(0, time), Age3 = rep(0, time)) pop_size[1, ] &lt;- N0 for (i in 2:time) { # Matrix multiplication pop_size[i, ] &lt;- leslie %*% t(pop_size[i-1, ]) } # Total abundance pop_size$N &lt;- rowSums(pop_size) head(pop_size) ## Age1 Age2 Age3 N ## 1 10.0 0.00 0.000 10.000 ## 2 0.0 5.00 0.000 5.000 ## 3 5.0 0.00 1.500 6.500 ## 4 7.5 2.50 0.000 10.000 ## 5 2.5 3.75 0.750 7.000 ## 6 7.5 1.25 1.125 9.875 plot(c(1,time), c(0,265), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;pop_size&quot;) lines(1:time , pop_size$Age1, col = &quot;red&quot;) lines(1:time , pop_size$Age2, col = &quot;blue&quot;) lines(1:time , pop_size$Age3, col = &quot;green&quot;) legend(&quot;topleft&quot;, legend = c(&quot;Age1&quot;, &quot;Age2&quot;, &quot;Age3&quot;), col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), lty = 1) Plot in log-scale: matplot(x = 1:time, y = log(pop_size[, 1:4]), type = &quot;l&quot;, lty = 1, col = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;), xlab = &quot;Time&quot;, ylab = &quot;log(population size)&quot;) legend(&quot;bottomright&quot;, c(&quot;Age 1&quot;, &quot;Age 2&quot;, &quot;Age 3&quot;, &quot;Total&quot;), bty = &quot;n&quot;, lty = 1 , col = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;)) By the derivation in the class, the asymptotic population sizes can be approximated by \\[ n_t \\approx c\\cdot \\lambda_1^t\\cdot u_1 \\] where \\(c\\) is a constant, \\(\\lambda_1\\) is the dominant eigenvalue and \\(u_1\\) is the corresponding eigenvector. Hence, with the long-term dynamics, the population grows at a rate \\(\\lambda_1\\) and with the age distribution \\(u_1\\). Here, we check this fact numerically. ### Asymptotic growth rate and stable age distribution asymptotic_growth &lt;- pop_size$N[time]/pop_size$N[time-1] asymptotic_growth ## [1] 1.089992 age_distribution &lt;- pop_size[time, 1:3]/sum(pop_size[time, 1:3]) age_distribution ## Age1 Age2 Age3 ## 50 0.6309262 0.2894167 0.07965713 ### Eigen-analysis of the Leslie matrix EIGEN &lt;- eigen(leslie) EIGEN ## eigen() decomposition ## $values ## [1] 1.0899905+0.0000000i -0.5449953+0.6253475i -0.5449953-0.6253475i ## ## $vectors ## [,1] [,2] [,3] ## [1,] 0.9030054+0i -0.8418972+0.0000000i -0.8418972+0.0000000i ## [2,] 0.4142263+0i 0.3334136+0.3825709i 0.3334136-0.3825709i ## [3,] 0.1140082+0i 0.0250833-0.1818099i 0.0250833+0.1818099i abs(EIGEN$values[1]) # dominant eigenvalue ## [1] 1.089991 as.numeric(EIGEN$vectors[, 1] / sum(EIGEN$vectors[, 1])) # corresponding eigenvector ## [1] 0.63092527 0.28941777 0.07965696 The asymptotic growth rate and stable age distribution obtained from for loops and eigen-analysis are similar. Part 3 - In-class exercise: Analyzing population matrix of common teasel Common teasel (Dipsacus sylvestris) is a herbaceous plant commonly found in abandoned fields and meadows in North America. It has a complex life cycle consisting of various stages. The seeds may lie dormant for one or two years. Seeds that germinate form small rosettes, which will gradually transit into medium and eventually large rosettes. These rosettes (all three sizes) may remain in the same stage for years before entering the next stage. After undergoing vernalization, large (and a few medium) rosettes will form stalks and flower in the upcoming summer, set seeds once, and die. Occasionally, the flowering plants will produce seeds that directly germinate into small/medium/large rosettes without entering dormancy. Here is a transition diagram for the teasel. Please convert this diagram into a stage-based transition matrix (Lefkovitch matrix) and derive the asymptotic growth rate \\(\\lambda\\) in R. ### Leslie matrix for Teasel Teasel &lt;- matrix(data = c(0, 0, 0, 0, 0, 322.38, 0.966, 0, 0, 0, 0, 0, 0.013, 0.010, 0.125, 0, 0, 3.448, 0.007, 0, 0.125, 0.238, 0, 30.17, 0.008, 0, 0, 0.245, 0.167, 0.862, 0, 0, 0, 0.023, 0.75, 0), nrow = 6, ncol = 6, byrow = T) ### Use eigen() function EIGEN &lt;- eigen(Teasel) ### Dominant eigenvalue abs(EIGEN$values[1]) ## [1] 2.32188 ### corresponding eigenvector round(as.numeric(EIGEN$vectors[, 1] / sum(EIGEN$vectors[, 1])), 3) ## [1] 0.637 0.265 0.012 0.069 0.012 0.005 Part 4 - COM(P)ADRE: A global database of population matrices COM(P)ADRE is an online repository containing matrix population models on hundreds of plants, animals, algae, fungi, bacteria, and viruses around the world, as well as their associated metadata. Take a look at the website: You will be exploring the population dynamics of a species (of your choice) in your assignment! "],["week-8---lotka-volterra-competition-model---population-dynamics.html", "Week 8 - Lotka-Volterra competition model - Population dynamics", " Week 8 - Lotka-Volterra competition model - Population dynamics In this lab, we are going to analyze the two-species Lotka-Volterra competition model numerically and visualize the population dynamics under different parameter settings. Part 1 - Visualize the Population Dynamics with Time Series library(ggplot2) library(tidyverse) library(deSolve) LV_model &lt;- function(r1 = 1.4, r2 = 1.2, a11 = 1/200, a21 = 1/400, a22 = 1/200, a12 = 1/300, N1_0 = 10, N2_0 = 10) { ### Model specification LV &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11*N1 - a12*N2) dN2_dt = N2 * (r2 - a22*N2 - a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } ### Model parameters times &lt;- seq(0, 100, by = 0.1) state &lt;- c(N1 = N1_0, N2 = N2_0) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) ### Model application pop_size &lt;- ode(func = LV, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;pop_size&quot;, -time) %&gt;% ggplot(aes(x = time, y = pop_size, color = Species)) + geom_line(size = 1.5) + theme_bw() } Plot the population dynamics under different parameter sets. ### Different parameter settings ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, N1_0 = 200, N2_0 = 5) # N1 wins ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, N1_0 = 10, N2_0 = 200) # N1 wins ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, N1_0 = 200, N2_0 = 5) # N2 wins ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, N1_0 = 5, N2_0 = 200) # N2 wins ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, N1_0 = 200, N2_0 = 5) # stable coexistence ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, N1_0 = 5, N2_0 = 200) # stable coexistence ## N1_0 = 200 and N2_0 = 150 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, N1_0 = 200, N2_0 = 150) # priority effect (N1 wins) ## N1_0 = 150 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, N1_0 = 150, N2_0 = 200) # priority effect (N2 wins) Part 2 - Visualize the Population Dynamics with State Space #### phase diagram phase_plane &lt;- function(r1, r2, a11, a21, a22, a12, title, t){ ### Vectors LV &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11*N1 - a12*N2) dN2_dt = N2 * (r2 - a22*N2 - a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } times &lt;- c(0, t) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) x_inter&lt;- max(c(r1/a11, r2/a21)) y_inter &lt;- max(c(r2/a22, r1/a12)) # create position of arrows vector_grid &lt;- expand.grid(seq(5, x_inter, length.out = 10), seq(5, y_inter, length.out = 10)) vector_data &lt;- vector_grid %&gt;% pmap(., function(Var1, Var2){ state &lt;- c(N1 = Var1, N2 = Var2) pop_size &lt;- ode(func = LV, times = times, y = state, parms = parms) pop_size[2, 2:3] }) %&gt;% bind_rows() %&gt;% rename(xend = N1, yend = N2) %&gt;% bind_cols(vector_grid) %&gt;% rename(x = Var1, y = Var2) ### Phase plane ggplot() + geom_abline(slope = -a11/a12, intercept = r1/a12, color = &quot;#E41A1C&quot;, size = 1.5) + geom_abline(slope = -a21/a22, intercept = r2/a22, color = &quot;#377EB8&quot;, size = 1.5) + geom_segment(data = vector_data, aes(x = x, y = y, xend = xend, yend = yend), arrow = arrow(length = unit(0.1, &quot;cm&quot;))) + scale_x_continuous(name = &quot;N1&quot;, limits = c(0, x_inter), expand = c(0, 0)) + scale_y_continuous(name = &quot;N2&quot;, limits = c(0, y_inter), expand = c(0, 0)) + theme_bw(base_size = 13) + theme(panel.grid = element_blank(), plot.title = element_text(hjust = 0.5), aspect.ratio = 1) + labs(title = title) } Plot the population dynamics under different parameter sets. phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/200, t = 0.2, title = &quot;Stable coexistence&quot;) phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, t = 0.2, title = &quot;Unstable coexistence (saddle)&quot;) phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, t = 0.2, title = &quot;N1 wins&quot;) phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, t = 0.2, title = &quot;N2 wins&quot;) "],["week-10---lotka-volterra-competition-model---visualization-of-dynamics-with-complex-eigenvalues.html", "Week 10 - Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues", " Week 10 - Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues Part 1 - Visualize the Trajectory of 2 Species Population Dynamics In class, we learned that the stability of a nonlinear ODE can be characterized by studying the dynamics of the “displacement for the equilibrium” (\\(\\pmb\\varepsilon\\)), which follows a much simpler linear ODE. If the linear ODE describing the dynamics of the displacement have a stable equilibrium at zero, then this indicates that the original equilibrium of the nonlinear ODE will also be stable. Consider the case where the dynamics of displacements \\(\\pmb\\varepsilon\\) can be described by the following linear ODE: \\[ \\dfrac{d \\vec{\\pmb\\varepsilon}}{d t} = \\mathcal{J}\\vec{\\pmb\\varepsilon} \\] where \\(\\vec{\\pmb\\varepsilon} = (\\varepsilon_1, \\varepsilon_2)^T\\) and \\(\\mathcal{J} = \\begin{pmatrix} -1 &amp; 1\\\\ -2 &amp; -1 \\end{pmatrix}\\). Or, we can write the linear system by two ODEs: \\[\\begin{align*} \\dfrac{d \\varepsilon_1}{d t} &amp;= (-1)\\times \\varepsilon_1 + (1)\\times\\varepsilon_2\\\\ \\dfrac{d \\varepsilon_2}{d t} &amp;= (-2)\\times \\varepsilon_1 + (-1)\\times\\varepsilon_2\\\\ \\end{align*}\\] We can see that this ODE has an equilibrium at zero and the eigenvalues are as follows, which have negative real parts (indicating that it’ll be stable) with a non-zero imaginary part (indicating that it’ll rotate towards the equilibrium, as shown below). eigen(matrix(c( -1, 1, -2, -1), 2, 2, T))$values # eigenvalues ## [1] -1+1.414214i -1-1.414214i library(ggplot2) library(tidyverse) library(deSolve) library(gganimate) library(gifski) ### Model specification ERROR &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { de1_dt = A * e1 + B * e2 de2_dt = C * e1 + D * e2 return(list(c(de1_dt, de2_dt))) }) } ### Imaginary eigenvalue ### Model parameters times &lt;- seq(0, 10, by = 0.0001) state &lt;- c(e1 = 0.1, e2 = 0.1) parms &lt;- c(A = -1, B = 1, C = -2, D = -1) ### Model application error_1 &lt;- ode(func = ERROR, times = times, y = state, parms = parms) plot(e2 ~ e1, error_1, type = &quot;l&quot;) abline(h = 0, lty = 3, col = &quot;red&quot;) abline(v = 0, lty = 3, col = &quot;red&quot;) ### Plot animation p1 &lt;- error_1 %&gt;% as.data.frame() %&gt;% ggplot(aes(x = e1, y = e2)) + geom_point() + geom_vline(xintercept = 0, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + geom_hline(yintercept = 0, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + labs(subtitle = &quot;Time: {round(frame_time, digit = 1)}&quot;) + transition_time(time) + shadow_wake(wake_length = 1) #gif1 &lt;- animate(p1, renderer = gifski_renderer()) #anim_save(filename = &quot;W10_dynamics_error_imaginary.gif&quot;, gif1) Here is another example that has negative real parts (indicating that it’ll be stable) with imaginary part equals to zero (indicating that it will not rotate but directly reaches the equilibrium, as shown below). times &lt;- seq(0, 10, by = 0.0001) state &lt;- c(e1 = 0.1, e2 = 0.1) parms &lt;- c(A = -1, B = 1, C = 0, D = -2) ### Model application error_2 &lt;- ode(func = ERROR, times = times, y = state, parms = parms) plot(e2 ~ e1, error_2, type = &quot;l&quot;) abline(h = 0, lty = 3, col = &quot;red&quot;) abline(v = 0, lty = 3, col = &quot;red&quot;) ### Plot animation p2 &lt;- error_2 %&gt;% as.data.frame() %&gt;% ggplot(aes(x = e1, y = e2)) + geom_point() + geom_vline(xintercept = 0, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + geom_hline(yintercept = 0, linetype=&quot;dashed&quot;, color = &quot;red&quot;) + labs(subtitle = &quot;Time: {round(frame_time, digit = 1)}&quot;) + transition_time(time) + shadow_wake(wake_length = 1) #gif2 &lt;- animate(p2, renderer = gifski_renderer()) #anim_save(filename = &quot;W10_dynamics_error_real.gif&quot;, gif2) Part 2 - Invasion Simulation In the following section, we are looking at how disturbances could affect population dynamics by doing reciprocal invasion simulations. LV_invasion &lt;- function(r1 = 1.0, r2 = 1.0, a11 = 0.05, a21 = 0.01, a22 = 0.05, a12 = 0.01, runtime = 100, invasion = c(50, 75)){ ### Model specification LV &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11 * N1 - a12 * N2) dN2_dt = N2 * (r2 - a22 * N2 - a21 * N1) return(list(c(dN1_dt, dN2_dt))) }) } ### Event function ### N2 invade N1-monoculture eventfun_2invade &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { N1 &lt;- N1 N2 &lt;- N2 + 1 return(c(N1, N2)) }) } ### N1 invade N2-monoculture eventfun_1invade &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { N1 &lt;- N1 + 1 N2 &lt;- N2 return(c(N1, N2)) }) } ### Model parameters times &lt;- seq(0, runtime, by = 0.1) state_1 &lt;- c(N1 = 5.0, N2 = 0.0) state_2 &lt;- c(N1 = 0.0, N2 = 5.0) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) ### Model application w/ event function ### N2 invade N1-monoculture pop_size_1 &lt;- ode(func = LV, times = times, y = state_1, parms = parms, events = list(func = eventfun_2invade, time = invasion)) ### N1 invade N2-monoculture pop_size_2 &lt;- ode(func = LV, times = times, y = state_2, parms = parms, events = list(func = eventfun_1invade, time = invasion)) ### Data manipulation Data &lt;- as.data.frame(rbind(pop_size_1, pop_size_2)) Data$Scenario &lt;-rep(c(&quot;N2 invade N1-monoculture&quot;, &quot;N1 invade N2-monoculture&quot;), each = length(times)) ### Visualize the population dynamics Data %&gt;% gather(key = &quot;Species&quot;, value = &quot;pop_size&quot;, -c(time, Scenario)) %&gt;% ggplot(aes(x = time, y = pop_size, color = Species)) + geom_line(linewidth = 1.5) + facet_grid(~Scenario) + theme_classic() + theme(legend.position = &quot;bottom&quot;) } Plot the population dynamics under different parameter sets. #### Run mutual invasion tests ### N1 win: N1 can invade &amp; N2 cannot invade LV_invasion(a11 = 0.01, a21 = 0.05, a22 = 0.05, a12 = 0.01) ### N2 win: N1 cannot invade &amp; N2 can invade LV_invasion(a11 = 0.05, a21 = 0.01, a22 = 0.01, a12 = 0.05) ### Coexist: N1 can invade &amp; N2 can invade LV_invasion(a11 = 0.05, a21 = 0.01, a22 = 0.05, a12 = 0.01) ### Priority Effect: N1 cannot invade &amp; N2 cannot invade LV_invasion(a11 = 0.01, a21 = 0.05, a22 = 0.01, a12 = 0.05) "]]
